{-
   IEX Haskell SDK

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.0
   IEX Haskell SDK API version: 1.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : IEXHaskellSDK.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module IEXHaskellSDK.Model where

import           IEXHaskellSDK.Core
import           IEXHaskellSDK.MimeTypes

import           Data.Aeson                     ( (.:)
                                                , (.:!)
                                                , (.:?)
                                                , (.=)
                                                )

import qualified Control.Arrow                 as P
                                                ( left )
import qualified Data.Aeson                    as A
import qualified Data.ByteString               as B
import qualified Data.ByteString.Base64        as B64
import qualified Data.ByteString.Char8         as BC
import qualified Data.ByteString.Lazy          as BL
import qualified Data.Data                     as P
                                                ( Typeable
                                                , TypeRep
                                                , typeOf
                                                , typeRep
                                                )
import qualified Data.Foldable                 as P
import qualified Data.HashMap.Lazy             as HM
import qualified Data.Map                      as Map
import qualified Data.Maybe                    as P
import qualified Data.Set                      as Set
import qualified Data.Text                     as T
import qualified Data.Text.Encoding            as T
import qualified Data.Time                     as TI
import qualified Lens.Micro                    as L
import qualified Web.FormUrlEncoded            as WH
import qualified Web.HttpApiData               as WH

import           Control.Applicative            ( (<|>) )
import           Control.Applicative            ( Alternative )
import           Data.Function                  ( (&) )
import           Data.Monoid                    ( (<>) )
import           Data.Text                      ( Text )
import           Prelude                        ( ($)
                                                , (/=)
                                                , (.)
                                                , (<$>)
                                                , (<*>)
                                                , (>>=)
                                                , (=<<)
                                                , Maybe(..)
                                                , Bool(..)
                                                , Char
                                                , Double
                                                , FilePath
                                                , Float
                                                , Int
                                                , Integer
                                                , String
                                                , fmap
                                                , undefined
                                                , mempty
                                                , maybe
                                                , pure
                                                , Monad
                                                , Applicative
                                                , Functor
                                                )

import qualified Prelude                       as P



-- * Parameter newtypes


-- ** ChangeFromClose
newtype ChangeFromClose = ChangeFromClose { unChangeFromClose :: Bool } deriving (P.Eq, P.Show)

-- ** ChartInterval
newtype ChartInterval = ChartInterval { unChartInterval :: Int } deriving (P.Eq, P.Show)

-- ** ChartLast
newtype ChartLast = ChartLast { unChartLast :: Int } deriving (P.Eq, P.Show)

-- ** ChartReset
newtype ChartReset = ChartReset { unChartReset :: Bool } deriving (P.Eq, P.Show)

-- ** ChartSimplify
newtype ChartSimplify = ChartSimplify { unChartSimplify :: Bool } deriving (P.Eq, P.Show)

-- ** CollectionName
newtype CollectionName = CollectionName { unCollectionName :: Sector } deriving (P.Eq, P.Show)

-- ** CollectionName2
newtype CollectionName2 = CollectionName2 { unCollectionName2 :: ModelList } deriving (P.Eq, P.Show)

-- ** DisplayPercent
newtype DisplayPercent = DisplayPercent { unDisplayPercent :: Bool } deriving (P.Eq, P.Show)

-- ** Format
newtype Format = Format { unFormat :: E'Format } deriving (P.Eq, P.Show)

-- ** Format2
newtype Format2 = Format2 { unFormat2 :: E'Format2 } deriving (P.Eq, P.Show)

-- ** Last
newtype Last = Last { unLast :: Int } deriving (P.Eq, P.Show)

-- ** ListType
newtype ListType = ListType { unListType :: E'ListType } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamDateInt
newtype ParamDateInt = ParamDateInt { unParamDateInt :: Int } deriving (P.Eq, P.Show)

-- ** Period
newtype Period = Period { unPeriod :: E'Period } deriving (P.Eq, P.Show)

-- ** Range
newtype Range = Range { unRange :: Int } deriving (P.Eq, P.Show)

-- ** Range2
newtype Range2 = Range2 { unRange2 :: E'Range2 } deriving (P.Eq, P.Show)

-- ** Symbol
newtype Symbol = Symbol { unSymbol :: Text } deriving (P.Eq, P.Show)

-- ** Symbols
newtype Symbols = Symbols { unSymbols :: [Text] } deriving (P.Eq, P.Show)

-- ** SymbolsText
newtype SymbolsText = SymbolsText { unSymbolsText :: Text } deriving (P.Eq, P.Show)

-- ** Token
newtype Token = Token { unToken :: Text } deriving (P.Eq, P.Show)

-- ** Types
newtype Types = Types { unTypes :: [E'Inner] } deriving (P.Eq, P.Show)

-- * Models


-- ** Article
-- | Article
data Article = Article
  { articleDatetime :: !(Maybe DateTime) -- ^ "datetime"
  , articleHeadline :: !(Maybe Text) -- ^ "headline"
  , articleSource :: !(Maybe Text) -- ^ "source" - Source of the news article. Make sure to always attribute the source
  , articleUrl :: !(Maybe Text) -- ^ "url"
  , articleSummary :: !(Maybe Text) -- ^ "summary"
  , articleRelated :: !(Maybe Text) -- ^ "related" - Comma-delimited list of tickers associated with this news article. Not all tickers are available on the API. Make sure to check against available &#x60;ref-data&#x60;
  , articleImage :: !(Maybe Text) -- ^ "image" - URL of associated news image
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Article
instance A.FromJSON Article where
  parseJSON = A.withObject "Article" $ \o ->
    Article
      <$> (o .:? "datetime")
      <*> (o .:? "headline")
      <*> (o .:? "source")
      <*> (o .:? "url")
      <*> (o .:? "summary")
      <*> (o .:? "related")
      <*> (o .:? "image")

-- | ToJSON Article
instance A.ToJSON Article where
  toJSON Article {..} = _omitNulls
    [ "datetime" .= articleDatetime
    , "headline" .= articleHeadline
    , "source" .= articleSource
    , "url" .= articleUrl
    , "summary" .= articleSummary
    , "related" .= articleRelated
    , "image" .= articleImage
    ]


-- | Construct a value of type 'Article' (by applying it's required fields, if any)
mkArticle :: Article
mkArticle = Article { articleDatetime = Nothing
                    , articleHeadline = Nothing
                    , articleSource   = Nothing
                    , articleUrl      = Nothing
                    , articleSummary  = Nothing
                    , articleRelated  = Nothing
                    , articleImage    = Nothing
                    }

-- ** Auction
-- | Auction
data Auction = Auction
  { auctionAuctionType :: !(Maybe E'AuctionType) -- ^ "auctionType" - refers to the auction type
  , auctionPairedShares :: !(Maybe Double) -- ^ "pairedShares" - refers to the number of shares paired at the &#x60;referencePrice&#x60; using order on the auction book
  , auctionImbalanceShares :: !(Maybe Double) -- ^ "imbalanceShares" - refers to the number of unpaired shares at the &#x60;referencePrice&#x60; using orders on the auction book
  , auctionReferencePrice :: !(Maybe Double) -- ^ "referencePrice" - refers to the clearing price at or within the reference price range using order on the auction book
  , auctionIndicativePrice :: !(Maybe Double) -- ^ "indicativePrice" - refers to the clearing price using eligible auction orders
  , auctionAuctionBookPrice :: !(Maybe Double) -- ^ "auctionBookPrice" - refers to the clearing price using orders on the auction book
  , auctionCollarReferencePrice :: !(Maybe Double) -- ^ "collarReferencePrice" - Refers to the reference price used for the auction collar, if any 
  , auctionLowerCollarPrice :: !(Maybe Double) -- ^ "lowerCollarPrice" - Refers to the lower threshold price of the auction collar, if any 
  , auctionUpperCollarPrice :: !(Maybe Double) -- ^ "upperCollarPrice" - Refers to the upper threshold price of the auction collar, if any 
  , auctionExtensionNumber :: !(Maybe Double) -- ^ "extensionNumber" - refers to the number of extensions an auction has received
  , auctionStartTime :: !(Maybe Text) -- ^ "startTime" - refers to the projected time of the auction match
  , auctionLastUpdate :: !(Maybe Double) -- ^ "lastUpdate" - refers to the timestamp of the auction information
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Auction
instance A.FromJSON Auction where
  parseJSON = A.withObject "Auction" $ \o ->
    Auction
      <$> (o .:? "auctionType")
      <*> (o .:? "pairedShares")
      <*> (o .:? "imbalanceShares")
      <*> (o .:? "referencePrice")
      <*> (o .:? "indicativePrice")
      <*> (o .:? "auctionBookPrice")
      <*> (o .:? "collarReferencePrice")
      <*> (o .:? "lowerCollarPrice")
      <*> (o .:? "upperCollarPrice")
      <*> (o .:? "extensionNumber")
      <*> (o .:? "startTime")
      <*> (o .:? "lastUpdate")

-- | ToJSON Auction
instance A.ToJSON Auction where
  toJSON Auction {..} = _omitNulls
    [ "auctionType" .= auctionAuctionType
    , "pairedShares" .= auctionPairedShares
    , "imbalanceShares" .= auctionImbalanceShares
    , "referencePrice" .= auctionReferencePrice
    , "indicativePrice" .= auctionIndicativePrice
    , "auctionBookPrice" .= auctionAuctionBookPrice
    , "collarReferencePrice" .= auctionCollarReferencePrice
    , "lowerCollarPrice" .= auctionLowerCollarPrice
    , "upperCollarPrice" .= auctionUpperCollarPrice
    , "extensionNumber" .= auctionExtensionNumber
    , "startTime" .= auctionStartTime
    , "lastUpdate" .= auctionLastUpdate
    ]


-- | Construct a value of type 'Auction' (by applying it's required fields, if any)
mkAuction :: Auction
mkAuction = Auction { auctionAuctionType          = Nothing
                    , auctionPairedShares         = Nothing
                    , auctionImbalanceShares      = Nothing
                    , auctionReferencePrice       = Nothing
                    , auctionIndicativePrice      = Nothing
                    , auctionAuctionBookPrice     = Nothing
                    , auctionCollarReferencePrice = Nothing
                    , auctionLowerCollarPrice     = Nothing
                    , auctionUpperCollarPrice     = Nothing
                    , auctionExtensionNumber      = Nothing
                    , auctionStartTime            = Nothing
                    , auctionLastUpdate           = Nothing
                    }

-- ** Chart1d
-- | Chart1d
data Chart1d = Chart1d
  { chart1dMinute :: !(Maybe Text) -- ^ "minute"
  , chart1dMarketAverage :: !(Maybe Double) -- ^ "marketAverage" - 15 minute delayed
  , chart1dMarketNotional :: !(Maybe Double) -- ^ "marketNotional" - 15 minute delayed
  , chart1dMarketNumberOfTrades :: !(Maybe Double) -- ^ "marketNumberOfTrades" - 15 minute delayed
  , chart1dMarketOpen :: !(Maybe Double) -- ^ "marketOpen" - 15 minute delayed
  , chart1dMarketClose :: !(Maybe Double) -- ^ "marketClose" - 15 minute delayed
  , chart1dMarketHigh :: !(Maybe Double) -- ^ "marketHigh" - 15 minute delayed
  , chart1dMarketLow :: !(Maybe Double) -- ^ "marketLow" - 15 minute delayed
  , chart1dMarketVolume :: !(Maybe Double) -- ^ "marketVolume" - 15 minute delayed
  , chart1dMarketChangeOverTime :: !(Maybe Double) -- ^ "marketChangeOverTime" - Percent change of each interval relative to first value. 15 minute delayed
  , chart1dAverage :: !(Maybe Double) -- ^ "average"
  , chart1dNotional :: !(Maybe Double) -- ^ "notional"
  , chart1dNumberOfTrades :: !(Maybe Double) -- ^ "numberOfTrades"
  , chart1dSimplifyFactor :: !(Maybe [Double]) -- ^ "simplifyFactor" - Only available when chartSimplify  is true. The first element is the original number of  points. Second element is how many remain after  simplification. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Chart1d
instance A.FromJSON Chart1d where
  parseJSON = A.withObject "Chart1d" $ \o ->
    Chart1d
      <$> (o .:? "minute")
      <*> (o .:? "marketAverage")
      <*> (o .:? "marketNotional")
      <*> (o .:? "marketNumberOfTrades")
      <*> (o .:? "marketOpen")
      <*> (o .:? "marketClose")
      <*> (o .:? "marketHigh")
      <*> (o .:? "marketLow")
      <*> (o .:? "marketVolume")
      <*> (o .:? "marketChangeOverTime")
      <*> (o .:? "average")
      <*> (o .:? "notional")
      <*> (o .:? "numberOfTrades")
      <*> (o .:? "simplifyFactor")

-- | ToJSON Chart1d
instance A.ToJSON Chart1d where
  toJSON Chart1d {..} = _omitNulls
    [ "minute" .= chart1dMinute
    , "marketAverage" .= chart1dMarketAverage
    , "marketNotional" .= chart1dMarketNotional
    , "marketNumberOfTrades" .= chart1dMarketNumberOfTrades
    , "marketOpen" .= chart1dMarketOpen
    , "marketClose" .= chart1dMarketClose
    , "marketHigh" .= chart1dMarketHigh
    , "marketLow" .= chart1dMarketLow
    , "marketVolume" .= chart1dMarketVolume
    , "marketChangeOverTime" .= chart1dMarketChangeOverTime
    , "average" .= chart1dAverage
    , "notional" .= chart1dNotional
    , "numberOfTrades" .= chart1dNumberOfTrades
    , "simplifyFactor" .= chart1dSimplifyFactor
    ]


-- | Construct a value of type 'Chart1d' (by applying it's required fields, if any)
mkChart1d :: Chart1d
mkChart1d = Chart1d { chart1dMinute               = Nothing
                    , chart1dMarketAverage        = Nothing
                    , chart1dMarketNotional       = Nothing
                    , chart1dMarketNumberOfTrades = Nothing
                    , chart1dMarketOpen           = Nothing
                    , chart1dMarketClose          = Nothing
                    , chart1dMarketHigh           = Nothing
                    , chart1dMarketLow            = Nothing
                    , chart1dMarketVolume         = Nothing
                    , chart1dMarketChangeOverTime = Nothing
                    , chart1dAverage              = Nothing
                    , chart1dNotional             = Nothing
                    , chart1dNumberOfTrades       = Nothing
                    , chart1dSimplifyFactor       = Nothing
                    }

-- ** ChartAll
-- | ChartAll
data ChartAll = ChartAll
  { chartAllHigh :: !(Maybe Double) -- ^ "high" - is available on all charts.
  , chartAllLow :: !(Maybe Double) -- ^ "low" - is available on all charts.
  , chartAllVolume :: !(Maybe Double) -- ^ "volume" - is available on all charts.
  , chartAllLabel :: !(Maybe Text) -- ^ "label" - is available on all charts. Percent change of each interval relative to first value. Useful for comparing multiple stocks.
  , chartAllChangeOverTime :: !(Maybe Double) -- ^ "changeOverTime" - is available on all charts.
  , chartAllDate :: !(Maybe Text) -- ^ "date" - is available on all charts.
  , chartAllOpen :: !(Maybe Double) -- ^ "open" - is available on all charts.
  , chartAllClose :: !(Maybe Double) -- ^ "close" - is available on all charts.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChartAll
instance A.FromJSON ChartAll where
  parseJSON = A.withObject "ChartAll" $ \o ->
    ChartAll
      <$> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "volume")
      <*> (o .:? "label")
      <*> (o .:? "changeOverTime")
      <*> (o .:? "date")
      <*> (o .:? "open")
      <*> (o .:? "close")

-- | ToJSON ChartAll
instance A.ToJSON ChartAll where
  toJSON ChartAll {..} = _omitNulls
    [ "high" .= chartAllHigh
    , "low" .= chartAllLow
    , "volume" .= chartAllVolume
    , "label" .= chartAllLabel
    , "changeOverTime" .= chartAllChangeOverTime
    , "date" .= chartAllDate
    , "open" .= chartAllOpen
    , "close" .= chartAllClose
    ]


-- | Construct a value of type 'ChartAll' (by applying it's required fields, if any)
mkChartAll :: ChartAll
mkChartAll = ChartAll { chartAllHigh           = Nothing
                      , chartAllLow            = Nothing
                      , chartAllVolume         = Nothing
                      , chartAllLabel          = Nothing
                      , chartAllChangeOverTime = Nothing
                      , chartAllDate           = Nothing
                      , chartAllOpen           = Nothing
                      , chartAllClose          = Nothing
                      }

-- ** ChartNot1d
-- | ChartNot1d
data ChartNot1d = ChartNot1d
  { chartNot1dUnadjustedVolume :: !(Maybe Double) -- ^ "unadjustedVolume"
  , chartNot1dChange :: !(Maybe Double) -- ^ "change"
  , chartNot1dChangePercent :: !(Maybe Double) -- ^ "changePercent"
  , chartNot1dVwap :: !(Maybe Double) -- ^ "vwap"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChartNot1d
instance A.FromJSON ChartNot1d where
  parseJSON = A.withObject "ChartNot1d" $ \o ->
    ChartNot1d
      <$> (o .:? "unadjustedVolume")
      <*> (o .:? "change")
      <*> (o .:? "changePercent")
      <*> (o .:? "vwap")

-- | ToJSON ChartNot1d
instance A.ToJSON ChartNot1d where
  toJSON ChartNot1d {..} = _omitNulls
    [ "unadjustedVolume" .= chartNot1dUnadjustedVolume
    , "change" .= chartNot1dChange
    , "changePercent" .= chartNot1dChangePercent
    , "vwap" .= chartNot1dVwap
    ]


-- | Construct a value of type 'ChartNot1d' (by applying it's required fields, if any)
mkChartNot1d :: ChartNot1d
mkChartNot1d = ChartNot1d { chartNot1dUnadjustedVolume = Nothing
                          , chartNot1dChange           = Nothing
                          , chartNot1dChangePercent    = Nothing
                          , chartNot1dVwap             = Nothing
                          }

-- ** CorporateAction
-- | CorporateAction
data CorporateAction = CorporateAction
  { corporateActionRecordId :: !(Maybe Text) -- ^ "RecordID"
  , corporateActionDailyListTimestamp :: !(Maybe Text) -- ^ "DailyListTimestamp"
  , corporateActionEffectiveDate :: !(Maybe Text) -- ^ "EffectiveDate"
  , corporateActionIssueEvent :: !(Maybe Text) -- ^ "IssueEvent"
  , corporateActionCurrentSymbolinInetSymbology :: !(Maybe Text) -- ^ "CurrentSymbolinINETSymbology"
  , corporateActionCurrentSymbolinCqsSymbology :: !(Maybe Text) -- ^ "CurrentSymbolinCQSSymbology"
  , corporateActionCurrentSymbolinCmsSymbology :: !(Maybe Text) -- ^ "CurrentSymbolinCMSSymbology"
  , corporateActionNewSymbolinInetSymbology :: !(Maybe Text) -- ^ "NewSymbolinINETSymbology"
  , corporateActionNewSymbolinCqsSymbology :: !(Maybe Text) -- ^ "NewSymbolinCQSSymbology"
  , corporateActionNewSymbolinCmsSymbology :: !(Maybe Text) -- ^ "NewSymbolinCMSSymbology"
  , corporateActionCurrentSecurityName :: !(Maybe Text) -- ^ "CurrentSecurityName"
  , corporateActionNewSecurityName :: !(Maybe Text) -- ^ "NewSecurityName"
  , corporateActionCurrentCompanyName :: !(Maybe Text) -- ^ "CurrentCompanyName"
  , corporateActionNewCompanyName :: !(Maybe Text) -- ^ "NewCompanyName"
  , corporateActionCurrentListingCenter :: !(Maybe Text) -- ^ "CurrentListingCenter"
  , corporateActionNewListingCenter :: !(Maybe Text) -- ^ "NewListingCenter"
  , corporateActionDelistingReason :: !(Maybe Text) -- ^ "DelistingReason"
  , corporateActionCurrentRoundLotSize :: !(Maybe Text) -- ^ "CurrentRoundLotSize"
  , corporateActionNewRoundLotSize :: !(Maybe Text) -- ^ "NewRoundLotSize"
  , corporateActionCurrentLuldTierIndicator :: !(Maybe Text) -- ^ "CurrentLULDTierIndicator"
  , corporateActionNewLuldTierIndicator :: !(Maybe Text) -- ^ "NewLULDTierIndicator"
  , corporateActionExpirationDate :: !(Maybe Text) -- ^ "ExpirationDate"
  , corporateActionSeparationDate :: !(Maybe Text) -- ^ "SeparationDate"
  , corporateActionSettlementDate :: !(Maybe Text) -- ^ "SettlementDate"
  , corporateActionMaturityDate :: !(Maybe Text) -- ^ "MaturityDate"
  , corporateActionRedemptionDate :: !(Maybe Text) -- ^ "RedemptionDate"
  , corporateActionCurrentFinancialStatus :: !(Maybe Text) -- ^ "CurrentFinancialStatus"
  , corporateActionNewFinancialStatus :: !(Maybe Text) -- ^ "NewFinancialStatus"
  , corporateActionWhenIssuedFlag :: !(Maybe Text) -- ^ "WhenIssuedFlag"
  , corporateActionWhenDistributedFlag :: !(Maybe Text) -- ^ "WhenDistributedFlag"
  , corporateActionIpoFlag :: !(Maybe Text) -- ^ "IPOFlag"
  , corporateActionHistoryHold :: !(Maybe Text) -- ^ "HistoryHold"
  , corporateActionNotesforEachEntry :: !(Maybe Text) -- ^ "NotesforEachEntry"
  , corporateActionRecordUpdateTime :: !(Maybe Text) -- ^ "RecordUpdateTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CorporateAction
instance A.FromJSON CorporateAction where
  parseJSON = A.withObject "CorporateAction" $ \o ->
    CorporateAction
      <$> (o .:? "RecordID")
      <*> (o .:? "DailyListTimestamp")
      <*> (o .:? "EffectiveDate")
      <*> (o .:? "IssueEvent")
      <*> (o .:? "CurrentSymbolinINETSymbology")
      <*> (o .:? "CurrentSymbolinCQSSymbology")
      <*> (o .:? "CurrentSymbolinCMSSymbology")
      <*> (o .:? "NewSymbolinINETSymbology")
      <*> (o .:? "NewSymbolinCQSSymbology")
      <*> (o .:? "NewSymbolinCMSSymbology")
      <*> (o .:? "CurrentSecurityName")
      <*> (o .:? "NewSecurityName")
      <*> (o .:? "CurrentCompanyName")
      <*> (o .:? "NewCompanyName")
      <*> (o .:? "CurrentListingCenter")
      <*> (o .:? "NewListingCenter")
      <*> (o .:? "DelistingReason")
      <*> (o .:? "CurrentRoundLotSize")
      <*> (o .:? "NewRoundLotSize")
      <*> (o .:? "CurrentLULDTierIndicator")
      <*> (o .:? "NewLULDTierIndicator")
      <*> (o .:? "ExpirationDate")
      <*> (o .:? "SeparationDate")
      <*> (o .:? "SettlementDate")
      <*> (o .:? "MaturityDate")
      <*> (o .:? "RedemptionDate")
      <*> (o .:? "CurrentFinancialStatus")
      <*> (o .:? "NewFinancialStatus")
      <*> (o .:? "WhenIssuedFlag")
      <*> (o .:? "WhenDistributedFlag")
      <*> (o .:? "IPOFlag")
      <*> (o .:? "HistoryHold")
      <*> (o .:? "NotesforEachEntry")
      <*> (o .:? "RecordUpdateTime")

-- | ToJSON CorporateAction
instance A.ToJSON CorporateAction where
  toJSON CorporateAction {..} = _omitNulls
    [ "RecordID" .= corporateActionRecordId
    , "DailyListTimestamp" .= corporateActionDailyListTimestamp
    , "EffectiveDate" .= corporateActionEffectiveDate
    , "IssueEvent" .= corporateActionIssueEvent
    , "CurrentSymbolinINETSymbology"
      .= corporateActionCurrentSymbolinInetSymbology
    , "CurrentSymbolinCQSSymbology"
      .= corporateActionCurrentSymbolinCqsSymbology
    , "CurrentSymbolinCMSSymbology"
      .= corporateActionCurrentSymbolinCmsSymbology
    , "NewSymbolinINETSymbology" .= corporateActionNewSymbolinInetSymbology
    , "NewSymbolinCQSSymbology" .= corporateActionNewSymbolinCqsSymbology
    , "NewSymbolinCMSSymbology" .= corporateActionNewSymbolinCmsSymbology
    , "CurrentSecurityName" .= corporateActionCurrentSecurityName
    , "NewSecurityName" .= corporateActionNewSecurityName
    , "CurrentCompanyName" .= corporateActionCurrentCompanyName
    , "NewCompanyName" .= corporateActionNewCompanyName
    , "CurrentListingCenter" .= corporateActionCurrentListingCenter
    , "NewListingCenter" .= corporateActionNewListingCenter
    , "DelistingReason" .= corporateActionDelistingReason
    , "CurrentRoundLotSize" .= corporateActionCurrentRoundLotSize
    , "NewRoundLotSize" .= corporateActionNewRoundLotSize
    , "CurrentLULDTierIndicator" .= corporateActionCurrentLuldTierIndicator
    , "NewLULDTierIndicator" .= corporateActionNewLuldTierIndicator
    , "ExpirationDate" .= corporateActionExpirationDate
    , "SeparationDate" .= corporateActionSeparationDate
    , "SettlementDate" .= corporateActionSettlementDate
    , "MaturityDate" .= corporateActionMaturityDate
    , "RedemptionDate" .= corporateActionRedemptionDate
    , "CurrentFinancialStatus" .= corporateActionCurrentFinancialStatus
    , "NewFinancialStatus" .= corporateActionNewFinancialStatus
    , "WhenIssuedFlag" .= corporateActionWhenIssuedFlag
    , "WhenDistributedFlag" .= corporateActionWhenDistributedFlag
    , "IPOFlag" .= corporateActionIpoFlag
    , "HistoryHold" .= corporateActionHistoryHold
    , "NotesforEachEntry" .= corporateActionNotesforEachEntry
    , "RecordUpdateTime" .= corporateActionRecordUpdateTime
    ]


-- | Construct a value of type 'CorporateAction' (by applying it's required fields, if any)
mkCorporateAction :: CorporateAction
mkCorporateAction = CorporateAction
  { corporateActionRecordId                     = Nothing
  , corporateActionDailyListTimestamp           = Nothing
  , corporateActionEffectiveDate                = Nothing
  , corporateActionIssueEvent                   = Nothing
  , corporateActionCurrentSymbolinInetSymbology = Nothing
  , corporateActionCurrentSymbolinCqsSymbology  = Nothing
  , corporateActionCurrentSymbolinCmsSymbology  = Nothing
  , corporateActionNewSymbolinInetSymbology     = Nothing
  , corporateActionNewSymbolinCqsSymbology      = Nothing
  , corporateActionNewSymbolinCmsSymbology      = Nothing
  , corporateActionCurrentSecurityName          = Nothing
  , corporateActionNewSecurityName              = Nothing
  , corporateActionCurrentCompanyName           = Nothing
  , corporateActionNewCompanyName               = Nothing
  , corporateActionCurrentListingCenter         = Nothing
  , corporateActionNewListingCenter             = Nothing
  , corporateActionDelistingReason              = Nothing
  , corporateActionCurrentRoundLotSize          = Nothing
  , corporateActionNewRoundLotSize              = Nothing
  , corporateActionCurrentLuldTierIndicator     = Nothing
  , corporateActionNewLuldTierIndicator         = Nothing
  , corporateActionExpirationDate               = Nothing
  , corporateActionSeparationDate               = Nothing
  , corporateActionSettlementDate               = Nothing
  , corporateActionMaturityDate                 = Nothing
  , corporateActionRedemptionDate               = Nothing
  , corporateActionCurrentFinancialStatus       = Nothing
  , corporateActionNewFinancialStatus           = Nothing
  , corporateActionWhenIssuedFlag               = Nothing
  , corporateActionWhenDistributedFlag          = Nothing
  , corporateActionIpoFlag                      = Nothing
  , corporateActionHistoryHold                  = Nothing
  , corporateActionNotesforEachEntry            = Nothing
  , corporateActionRecordUpdateTime             = Nothing
  }

-- ** DividendCoreData
-- | DividendCoreData
data DividendCoreData = DividendCoreData
  { dividendCoreDataRecordId :: !(Maybe Text) -- ^ "RecordId"
  , dividendCoreDataDailyListTimestamp :: !(Maybe Text) -- ^ "DailyListTimestamp"
  , dividendCoreDataSymbolinInetSymbology :: !(Maybe Text) -- ^ "SymbolinINETSymbology"
  , dividendCoreDataSymbolinCqsSymbology :: !(Maybe Text) -- ^ "SymbolinCQSSymbology"
  , dividendCoreDataSymbolyinCmsSymbology :: !(Maybe Text) -- ^ "SymbolyinCMSSymbology"
  , dividendCoreDataSecurityName :: !(Maybe Text) -- ^ "SecurityName"
  , dividendCoreDataCompanyName :: !(Maybe Text) -- ^ "CompanyName"
  , dividendCoreDataAmountDescription :: !(Maybe Text) -- ^ "AmountDescription"
  , dividendCoreDataPaymentFrequency :: !(Maybe Text) -- ^ "PaymentFrequency"
  , dividendCoreDataExDate :: !(Maybe Text) -- ^ "ExDate"
  , dividendCoreDataDividendTypeId :: !(Maybe Text) -- ^ "DividendTypeID"
  , dividendCoreDataStockAdjustmentFactor :: !(Maybe Text) -- ^ "StockAdjustmentFactor"
  , dividendCoreDataStockAmount :: !(Maybe Text) -- ^ "StockAmount"
  , dividendCoreDataCashAmount :: !(Maybe Text) -- ^ "CashAmount"
  , dividendCoreDataPostSplitShares :: !(Maybe Text) -- ^ "PostSplitShares"
  , dividendCoreDataPreSplitShares :: !(Maybe Text) -- ^ "PreSplitShares"
  , dividendCoreDataQualifiedDividend :: !(Maybe Text) -- ^ "QualifiedDividend"
  , dividendCoreDataExercisePriceAmount :: !(Maybe Text) -- ^ "ExercisePriceAmount"
  , dividendCoreDataElectionorExpirationDate :: !(Maybe Text) -- ^ "ElectionorExpirationDate"
  , dividendCoreDataGrossAmount :: !(Maybe Text) -- ^ "GrossAmount"
  , dividendCoreDataNetAmount :: !(Maybe Text) -- ^ "NetAmount"
  , dividendCoreDataBasisNotes :: !(Maybe Text) -- ^ "BasisNotes"
  , dividendCoreDataNotesforEachEntry :: !(Maybe Text) -- ^ "NotesforEachEntry"
  , dividendCoreDataRecordUpdateTime :: !(Maybe Text) -- ^ "RecordUpdateTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DividendCoreData
instance A.FromJSON DividendCoreData where
  parseJSON = A.withObject "DividendCoreData" $ \o ->
    DividendCoreData
      <$> (o .:? "RecordId")
      <*> (o .:? "DailyListTimestamp")
      <*> (o .:? "SymbolinINETSymbology")
      <*> (o .:? "SymbolinCQSSymbology")
      <*> (o .:? "SymbolyinCMSSymbology")
      <*> (o .:? "SecurityName")
      <*> (o .:? "CompanyName")
      <*> (o .:? "AmountDescription")
      <*> (o .:? "PaymentFrequency")
      <*> (o .:? "ExDate")
      <*> (o .:? "DividendTypeID")
      <*> (o .:? "StockAdjustmentFactor")
      <*> (o .:? "StockAmount")
      <*> (o .:? "CashAmount")
      <*> (o .:? "PostSplitShares")
      <*> (o .:? "PreSplitShares")
      <*> (o .:? "QualifiedDividend")
      <*> (o .:? "ExercisePriceAmount")
      <*> (o .:? "ElectionorExpirationDate")
      <*> (o .:? "GrossAmount")
      <*> (o .:? "NetAmount")
      <*> (o .:? "BasisNotes")
      <*> (o .:? "NotesforEachEntry")
      <*> (o .:? "RecordUpdateTime")

-- | ToJSON DividendCoreData
instance A.ToJSON DividendCoreData where
  toJSON DividendCoreData {..} = _omitNulls
    [ "RecordId" .= dividendCoreDataRecordId
    , "DailyListTimestamp" .= dividendCoreDataDailyListTimestamp
    , "SymbolinINETSymbology" .= dividendCoreDataSymbolinInetSymbology
    , "SymbolinCQSSymbology" .= dividendCoreDataSymbolinCqsSymbology
    , "SymbolyinCMSSymbology" .= dividendCoreDataSymbolyinCmsSymbology
    , "SecurityName" .= dividendCoreDataSecurityName
    , "CompanyName" .= dividendCoreDataCompanyName
    , "AmountDescription" .= dividendCoreDataAmountDescription
    , "PaymentFrequency" .= dividendCoreDataPaymentFrequency
    , "ExDate" .= dividendCoreDataExDate
    , "DividendTypeID" .= dividendCoreDataDividendTypeId
    , "StockAdjustmentFactor" .= dividendCoreDataStockAdjustmentFactor
    , "StockAmount" .= dividendCoreDataStockAmount
    , "CashAmount" .= dividendCoreDataCashAmount
    , "PostSplitShares" .= dividendCoreDataPostSplitShares
    , "PreSplitShares" .= dividendCoreDataPreSplitShares
    , "QualifiedDividend" .= dividendCoreDataQualifiedDividend
    , "ExercisePriceAmount" .= dividendCoreDataExercisePriceAmount
    , "ElectionorExpirationDate" .= dividendCoreDataElectionorExpirationDate
    , "GrossAmount" .= dividendCoreDataGrossAmount
    , "NetAmount" .= dividendCoreDataNetAmount
    , "BasisNotes" .= dividendCoreDataBasisNotes
    , "NotesforEachEntry" .= dividendCoreDataNotesforEachEntry
    , "RecordUpdateTime" .= dividendCoreDataRecordUpdateTime
    ]


-- | Construct a value of type 'DividendCoreData' (by applying it's required fields, if any)
mkDividendCoreData :: DividendCoreData
mkDividendCoreData = DividendCoreData
  { dividendCoreDataRecordId                 = Nothing
  , dividendCoreDataDailyListTimestamp       = Nothing
  , dividendCoreDataSymbolinInetSymbology    = Nothing
  , dividendCoreDataSymbolinCqsSymbology     = Nothing
  , dividendCoreDataSymbolyinCmsSymbology    = Nothing
  , dividendCoreDataSecurityName             = Nothing
  , dividendCoreDataCompanyName              = Nothing
  , dividendCoreDataAmountDescription        = Nothing
  , dividendCoreDataPaymentFrequency         = Nothing
  , dividendCoreDataExDate                   = Nothing
  , dividendCoreDataDividendTypeId           = Nothing
  , dividendCoreDataStockAdjustmentFactor    = Nothing
  , dividendCoreDataStockAmount              = Nothing
  , dividendCoreDataCashAmount               = Nothing
  , dividendCoreDataPostSplitShares          = Nothing
  , dividendCoreDataPreSplitShares           = Nothing
  , dividendCoreDataQualifiedDividend        = Nothing
  , dividendCoreDataExercisePriceAmount      = Nothing
  , dividendCoreDataElectionorExpirationDate = Nothing
  , dividendCoreDataGrossAmount              = Nothing
  , dividendCoreDataNetAmount                = Nothing
  , dividendCoreDataBasisNotes               = Nothing
  , dividendCoreDataNotesforEachEntry        = Nothing
  , dividendCoreDataRecordUpdateTime         = Nothing
  }

-- ** Earnings
-- | Earnings
data Earnings = Earnings
  { earningsActualEps :: !(Maybe Double) -- ^ "actualEPS" - Actual earnings per share for the period
  , earningsConsensusEps :: !(Maybe Double) -- ^ "consensusEPS" - Consensus EPS estimate trend for the period
  , earningsEstimatedEps :: !(Maybe Double) -- ^ "estimatedEPS" - Earinings per share estimate for the period
  , earningsAnnounceTime :: !(Maybe Text) -- ^ "announceTime" - Time of earnings announcement:   * BTO &#x3D; before open   * DMT &#x3D; during trading   * AMC &#x3D; after close 
  , earningsNumberOfEstimates :: !(Maybe Double) -- ^ "numberOfEstimates" - Number of estimates for the period
  , earningsEpsSurpriseDollar :: !(Maybe Double) -- ^ "EPSSurpriseDollar" - Dollar amount of EPS surprise for the period
  , earningsEpsReportDate :: !(Maybe Date) -- ^ "EPSReportDate" - Expected eariings report date &#x60;YYYY-MM-DD&#x60;
  , earningsFiscalPeriod :: !(Maybe Text) -- ^ "fiscalPeriod" - The fiscal quarter the earnings data applies to &#x60;Q# YYYY&#x60;
  , earningsFiscalEndDate :: !(Maybe Date) -- ^ "fiscalEndDate" - Date representing the company fiscal quarter end &#x60;YYYY-MM-DD&#x60;
  , earningsYearAgo :: !(Maybe Double) -- ^ "yearAgo" - Represents the EPS of the quarter a year ago
  , earningsYearAgoChangePercent :: !(Maybe Double) -- ^ "yearAgoChangePercent" - Represents the percent difference between the quarter a year ago &#x60;actualEPS&#x60; and current period &#x60;actualEPS&#x60;.
  , earningsEstimatedChangePercent :: !(Maybe Double) -- ^ "estimatedChangePercent" - Represents the percent difference between the quarter a year ago &#x60;actualEPS&#x60; and current period &#x60;estimatedEPS&#x60;
  , earningsSymbolId :: !(Maybe Double) -- ^ "symbolId" - Represents the IEX id for the stock
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Earnings
instance A.FromJSON Earnings where
  parseJSON = A.withObject "Earnings" $ \o ->
    Earnings
      <$> (o .:? "actualEPS")
      <*> (o .:? "consensusEPS")
      <*> (o .:? "estimatedEPS")
      <*> (o .:? "announceTime")
      <*> (o .:? "numberOfEstimates")
      <*> (o .:? "EPSSurpriseDollar")
      <*> (o .:? "EPSReportDate")
      <*> (o .:? "fiscalPeriod")
      <*> (o .:? "fiscalEndDate")
      <*> (o .:? "yearAgo")
      <*> (o .:? "yearAgoChangePercent")
      <*> (o .:? "estimatedChangePercent")
      <*> (o .:? "symbolId")

-- | ToJSON Earnings
instance A.ToJSON Earnings where
  toJSON Earnings {..} = _omitNulls
    [ "actualEPS" .= earningsActualEps
    , "consensusEPS" .= earningsConsensusEps
    , "estimatedEPS" .= earningsEstimatedEps
    , "announceTime" .= earningsAnnounceTime
    , "numberOfEstimates" .= earningsNumberOfEstimates
    , "EPSSurpriseDollar" .= earningsEpsSurpriseDollar
    , "EPSReportDate" .= earningsEpsReportDate
    , "fiscalPeriod" .= earningsFiscalPeriod
    , "fiscalEndDate" .= earningsFiscalEndDate
    , "yearAgo" .= earningsYearAgo
    , "yearAgoChangePercent" .= earningsYearAgoChangePercent
    , "estimatedChangePercent" .= earningsEstimatedChangePercent
    , "symbolId" .= earningsSymbolId
    ]


-- | Construct a value of type 'Earnings' (by applying it's required fields, if any)
mkEarnings :: Earnings
mkEarnings = Earnings { earningsActualEps              = Nothing
                      , earningsConsensusEps           = Nothing
                      , earningsEstimatedEps           = Nothing
                      , earningsAnnounceTime           = Nothing
                      , earningsNumberOfEstimates      = Nothing
                      , earningsEpsSurpriseDollar      = Nothing
                      , earningsEpsReportDate          = Nothing
                      , earningsFiscalPeriod           = Nothing
                      , earningsFiscalEndDate          = Nothing
                      , earningsYearAgo                = Nothing
                      , earningsYearAgoChangePercent   = Nothing
                      , earningsEstimatedChangePercent = Nothing
                      , earningsSymbolId               = Nothing
                      }

-- ** Financials
-- | Financials
data Financials = Financials
  { financialsReportDate :: !(Maybe Text) -- ^ "reportDate"
  , financialsGrossProfit :: !(Maybe Double) -- ^ "grossProfit"
  , financialsCostOfRevenue :: !(Maybe Double) -- ^ "costOfRevenue"
  , financialsOperatingRevenue :: !(Maybe Double) -- ^ "operatingRevenue"
  , financialsTotalRevenue :: !(Maybe Double) -- ^ "totalRevenue"
  , financialsOperatingIncome :: !(Maybe Double) -- ^ "operatingIncome"
  , financialsNetIncome :: !(Maybe Double) -- ^ "netIncome"
  , financialsResearchAndDevelopment :: !(Maybe Double) -- ^ "researchAndDevelopment"
  , financialsOperatingExpense :: !(Maybe Double) -- ^ "operatingExpense"
  , financialsCurrentAssets :: !(Maybe Double) -- ^ "currentAssets"
  , financialsTotalAssets :: !(Maybe Double) -- ^ "totalAssets"
  , financialsTotalLiabilities :: !(Maybe Double) -- ^ "totalLiabilities"
  , financialsCurrentCash :: !(Maybe Double) -- ^ "currentCash"
  , financialsCurrentDebt :: !(Maybe Double) -- ^ "currentDebt"
  , financialsTotalCash :: !(Maybe Double) -- ^ "totalCash"
  , financialsTotalDebt :: !(Maybe Double) -- ^ "totalDebt"
  , financialsShareholderEquity :: !(Maybe Double) -- ^ "shareholderEquity"
  , financialsCashChange :: !(Maybe Double) -- ^ "cashChange"
  , financialsCashFlow :: !(Maybe Double) -- ^ "cashFlow"
  , financialsOperatingGainsLosses :: !(Maybe Text) -- ^ "operatingGainsLosses"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Financials
instance A.FromJSON Financials where
  parseJSON = A.withObject "Financials" $ \o ->
    Financials
      <$> (o .:? "reportDate")
      <*> (o .:? "grossProfit")
      <*> (o .:? "costOfRevenue")
      <*> (o .:? "operatingRevenue")
      <*> (o .:? "totalRevenue")
      <*> (o .:? "operatingIncome")
      <*> (o .:? "netIncome")
      <*> (o .:? "researchAndDevelopment")
      <*> (o .:? "operatingExpense")
      <*> (o .:? "currentAssets")
      <*> (o .:? "totalAssets")
      <*> (o .:? "totalLiabilities")
      <*> (o .:? "currentCash")
      <*> (o .:? "currentDebt")
      <*> (o .:? "totalCash")
      <*> (o .:? "totalDebt")
      <*> (o .:? "shareholderEquity")
      <*> (o .:? "cashChange")
      <*> (o .:? "cashFlow")
      <*> (o .:? "operatingGainsLosses")

-- | ToJSON Financials
instance A.ToJSON Financials where
  toJSON Financials {..} = _omitNulls
    [ "reportDate" .= financialsReportDate
    , "grossProfit" .= financialsGrossProfit
    , "costOfRevenue" .= financialsCostOfRevenue
    , "operatingRevenue" .= financialsOperatingRevenue
    , "totalRevenue" .= financialsTotalRevenue
    , "operatingIncome" .= financialsOperatingIncome
    , "netIncome" .= financialsNetIncome
    , "researchAndDevelopment" .= financialsResearchAndDevelopment
    , "operatingExpense" .= financialsOperatingExpense
    , "currentAssets" .= financialsCurrentAssets
    , "totalAssets" .= financialsTotalAssets
    , "totalLiabilities" .= financialsTotalLiabilities
    , "currentCash" .= financialsCurrentCash
    , "currentDebt" .= financialsCurrentDebt
    , "totalCash" .= financialsTotalCash
    , "totalDebt" .= financialsTotalDebt
    , "shareholderEquity" .= financialsShareholderEquity
    , "cashChange" .= financialsCashChange
    , "cashFlow" .= financialsCashFlow
    , "operatingGainsLosses" .= financialsOperatingGainsLosses
    ]


-- | Construct a value of type 'Financials' (by applying it's required fields, if any)
mkFinancials :: Financials
mkFinancials = Financials { financialsReportDate             = Nothing
                          , financialsGrossProfit            = Nothing
                          , financialsCostOfRevenue          = Nothing
                          , financialsOperatingRevenue       = Nothing
                          , financialsTotalRevenue           = Nothing
                          , financialsOperatingIncome        = Nothing
                          , financialsNetIncome              = Nothing
                          , financialsResearchAndDevelopment = Nothing
                          , financialsOperatingExpense       = Nothing
                          , financialsCurrentAssets          = Nothing
                          , financialsTotalAssets            = Nothing
                          , financialsTotalLiabilities       = Nothing
                          , financialsCurrentCash            = Nothing
                          , financialsCurrentDebt            = Nothing
                          , financialsTotalCash              = Nothing
                          , financialsTotalDebt              = Nothing
                          , financialsShareholderEquity      = Nothing
                          , financialsCashChange             = Nothing
                          , financialsCashFlow               = Nothing
                          , financialsOperatingGainsLosses   = Nothing
                          }

-- ** DeepBookGetResponse
-- | DeepBookGetResponse
data DeepBookGetResponse = DeepBookGetResponse
  { deepBookGetResponseBids :: !(Maybe [Order]) -- ^ "bids"
  , deepBookGetResponseAsks :: !(Maybe [Order]) -- ^ "asks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepBookGetResponse
instance A.FromJSON DeepBookGetResponse where
  parseJSON = A.withObject "DeepBookGetResponse"
    $ \o -> DeepBookGetResponse <$> (o .:? "bids") <*> (o .:? "asks")

-- | ToJSON DeepBookGetResponse
instance A.ToJSON DeepBookGetResponse where
  toJSON DeepBookGetResponse {..} = _omitNulls
    ["bids" .= deepBookGetResponseBids, "asks" .= deepBookGetResponseAsks]


-- | Construct a value of type 'DeepBookGetResponse' (by applying it's required fields, if any)
mkDeepBookGetResponse :: DeepBookGetResponse
mkDeepBookGetResponse = DeepBookGetResponse { deepBookGetResponseBids = Nothing
                                            , deepBookGetResponseAsks = Nothing
                                            }

-- ** DeepGetResponse
-- | DeepGetResponse
data DeepGetResponse= DeepGetResponse
  { deepGetResponseSymbol :: !(Maybe Text) -- ^ "symbol"
  , deepGetResponseMarketPercent :: !(Maybe Double) -- ^ "marketPercent"
  , deepGetResponseVolume :: !(Maybe Double) -- ^ "volume"
  , deepGetResponseLastSalePrice :: !(Maybe Double) -- ^ "lastSalePrice"
  , deepGetResponseLastSaleSize :: !(Maybe Double) -- ^ "lastSaleSize"
  , deepGetResponseLastSaleTime :: !(Maybe Double) -- ^ "lastSaleTime"
  , deepGetResponseLastUpdated :: !(Maybe Double) -- ^ "lastUpdated"
  , deepGetResponseBids :: !(Maybe [Order]) -- ^ "bids"
  , deepGetResponseAsks :: !(Maybe [Order]) -- ^ "asks"
  , deepGetResponseSystemEvent :: !(Maybe [SystemEvent]) -- ^ "systemEvent"
  , deepGetResponseTradingStatus :: !(Maybe DeepGetResponseTradingStatus) -- ^ "tradingStatus"
  , deepGetResponseOpHaltStatus :: !(Maybe DeepGetResponseOpHaltStatus) -- ^ "opHaltStatus"
  , deepGetResponseSsrStatus :: !(Maybe DeepGetResponseSsrStatus) -- ^ "ssrStatus"
  , deepGetResponseSecurityEvent :: !(Maybe DeepGetResponseSecurityEvent) -- ^ "securityEvent"
  , deepGetResponseTrades :: !(Maybe [Trade]) -- ^ "trades"
  , deepGetResponseTradeBreaks :: !(Maybe [DeepGetResponseTradeBreaks]) -- ^ "tradeBreaks"
  , deepGetResponseAuction :: !(Maybe DeepGetResponseAuction) -- ^ "auction"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepGetResponse
instance A.FromJSON DeepGetResponse where
  parseJSON = A.withObject "DeepGetResponse" $ \o ->
    DeepGetResponse
      <$> (o .:? "symbol")
      <*> (o .:? "marketPercent")
      <*> (o .:? "volume")
      <*> (o .:? "lastSalePrice")
      <*> (o .:? "lastSaleSize")
      <*> (o .:? "lastSaleTime")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "bids")
      <*> (o .:? "asks")
      <*> (o .:? "systemEvent")
      <*> (o .:? "tradingStatus")
      <*> (o .:? "opHaltStatus")
      <*> (o .:? "ssrStatus")
      <*> (o .:? "securityEvent")
      <*> (o .:? "trades")
      <*> (o .:? "tradeBreaks")
      <*> (o .:? "auction")

-- | ToJSON DeepGetResponse
instance A.ToJSON DeepGetResponse where
  toJSON DeepGetResponse {..} = _omitNulls
    [ "symbol" .= deepGetResponseSymbol
    , "marketPercent" .= deepGetResponseMarketPercent
    , "volume" .= deepGetResponseVolume
    , "lastSalePrice" .= deepGetResponseLastSalePrice
    , "lastSaleSize" .= deepGetResponseLastSaleSize
    , "lastSaleTime" .= deepGetResponseLastSaleTime
    , "lastUpdated" .= deepGetResponseLastUpdated
    , "bids" .= deepGetResponseBids
    , "asks" .= deepGetResponseAsks
    , "systemEvent" .= deepGetResponseSystemEvent
    , "tradingStatus" .= deepGetResponseTradingStatus
    , "opHaltStatus" .= deepGetResponseOpHaltStatus
    , "ssrStatus" .= deepGetResponseSsrStatus
    , "securityEvent" .= deepGetResponseSecurityEvent
    , "trades" .= deepGetResponseTrades
    , "tradeBreaks" .= deepGetResponseTradeBreaks
    , "auction" .= deepGetResponseAuction
    ]


-- | Construct a value of type 'DeepGetResponse' (by applying it's required fields, if any)
mkDeepGetResponse :: DeepGetResponse
mkDeepGetResponse = DeepGetResponse { deepGetResponseSymbol        = Nothing
                                    , deepGetResponseMarketPercent = Nothing
                                    , deepGetResponseVolume        = Nothing
                                    , deepGetResponseLastSalePrice = Nothing
                                    , deepGetResponseLastSaleSize  = Nothing
                                    , deepGetResponseLastSaleTime  = Nothing
                                    , deepGetResponseLastUpdated   = Nothing
                                    , deepGetResponseBids          = Nothing
                                    , deepGetResponseAsks          = Nothing
                                    , deepGetResponseSystemEvent   = Nothing
                                    , deepGetResponseTradingStatus = Nothing
                                    , deepGetResponseOpHaltStatus  = Nothing
                                    , deepGetResponseSsrStatus     = Nothing
                                    , deepGetResponseSecurityEvent = Nothing
                                    , deepGetResponseTrades        = Nothing
                                    , deepGetResponseTradeBreaks   = Nothing
                                    , deepGetResponseAuction       = Nothing
                                    }

-- ** StatsHistoricalDailyGetResponse
-- | StatsHistoricalDailyGetResponse
data StatsHistoricalDailyGetResponse = StatsHistoricalDailyGetResponse
  { statsHistoricalDailyGetResponseDate :: !(Maybe Text) -- ^ "date"
  , statsHistoricalDailyGetResponseVolume :: !(Maybe Double) -- ^ "volume"
  , statsHistoricalDailyGetResponseRoutedVolume :: !(Maybe Double) -- ^ "routedVolume"
  , statsHistoricalDailyGetResponseMarketShare :: !(Maybe Double) -- ^ "marketShare"
  , statsHistoricalDailyGetResponseIsHalfday :: !(Maybe Double) -- ^ "isHalfday"
  , statsHistoricalDailyGetResponseLitVolume :: !(Maybe Double) -- ^ "litVolume"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatsHistoricalDailyGetResponse
instance A.FromJSON StatsHistoricalDailyGetResponse where
  parseJSON = A.withObject "StatsHistoricalDailyGetResponse" $ \o ->
    StatsHistoricalDailyGetResponse
      <$> (o .:? "date")
      <*> (o .:? "volume")
      <*> (o .:? "routedVolume")
      <*> (o .:? "marketShare")
      <*> (o .:? "isHalfday")
      <*> (o .:? "litVolume")

-- | ToJSON StatsHistoricalDailyGetResponse
instance A.ToJSON StatsHistoricalDailyGetResponse where
  toJSON StatsHistoricalDailyGetResponse {..} = _omitNulls
    [ "date" .= statsHistoricalDailyGetResponseDate
    , "volume" .= statsHistoricalDailyGetResponseVolume
    , "routedVolume" .= statsHistoricalDailyGetResponseRoutedVolume
    , "marketShare" .= statsHistoricalDailyGetResponseMarketShare
    , "isHalfday" .= statsHistoricalDailyGetResponseIsHalfday
    , "litVolume" .= statsHistoricalDailyGetResponseLitVolume
    ]


-- | Construct a value of type 'StatsHistoricalDailyGetResponse' (by applying it's required fields, if any)
mkStatsHistoricalDailyGetResponse :: StatsHistoricalDailyGetResponse
mkStatsHistoricalDailyGetResponse = StatsHistoricalDailyGetResponse
  { statsHistoricalDailyGetResponseDate         = Nothing
  , statsHistoricalDailyGetResponseVolume       = Nothing
  , statsHistoricalDailyGetResponseRoutedVolume = Nothing
  , statsHistoricalDailyGetResponseMarketShare  = Nothing
  , statsHistoricalDailyGetResponseIsHalfday    = Nothing
  , statsHistoricalDailyGetResponseLitVolume    = Nothing
  }

-- ** StatsIntradayGetResponse
-- | StatsIntradayGetResponse
-- * volume refers to single counted shares matched from executions on IEX * symbolsTraded refers to number of symbols traded on IEX * routedVolume refers to executions received from orders routed to away trading centers * notional refers to sum of matched volume times execution price of those trades * marketShare refers to IEX's percentage of total US Equity market volume * lastUpdated refers to the last update time of the data in muilliseconds since midnight Jan 1, 1970 
data StatsIntradayGetResponse = StatsIntradayGetResponse
  { statsIntradayGetResponseVolume :: !(Maybe TimestampedValue) -- ^ "volume"
  , statsIntradayGetResponseSymbolsTraded :: !(Maybe TimestampedValue) -- ^ "symbolsTraded"
  , statsIntradayGetResponseRoutedVolume :: !(Maybe TimestampedValue) -- ^ "routedVolume"
  , statsIntradayGetResponseNotional :: !(Maybe TimestampedValue) -- ^ "notional"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatsIntradayGetResponse
instance A.FromJSON StatsIntradayGetResponse where
  parseJSON = A.withObject "StatsIntradayGetResponse" $ \o ->
    StatsIntradayGetResponse
      <$> (o .:? "volume")
      <*> (o .:? "symbolsTraded")
      <*> (o .:? "routedVolume")
      <*> (o .:? "notional")

-- | ToJSON StatsIntradayGetResponse
instance A.ToJSON StatsIntradayGetResponse where
  toJSON StatsIntradayGetResponse {..} = _omitNulls
    [ "volume" .= statsIntradayGetResponseVolume
    , "symbolsTraded" .= statsIntradayGetResponseSymbolsTraded
    , "routedVolume" .= statsIntradayGetResponseRoutedVolume
    , "notional" .= statsIntradayGetResponseNotional
    ]


-- | Construct a value of type 'StatsIntradayGetResponse' (by applying it's required fields, if any)
mkStatsIntradayGetResponse :: StatsIntradayGetResponse
mkStatsIntradayGetResponse = StatsIntradayGetResponse
  { statsIntradayGetResponseVolume        = Nothing
  , statsIntradayGetResponseSymbolsTraded = Nothing
  , statsIntradayGetResponseRoutedVolume  = Nothing
  , statsIntradayGetResponseNotional      = Nothing
  }

-- ** StatsRecentGetResponse
-- | StatsRecentGetResponse
data StatsRecentGetResponse = StatsRecentGetResponse
  { statsRecentGetResponseDate :: !(Maybe Date) -- ^ "date" - Refers to the trading day
  , statsRecentGetResponseVolume :: !(Maybe Double) -- ^ "volume" - refers to executions received from order routed to away trading centers
  , statsRecentGetResponseRoutedVolume :: !(Maybe Double) -- ^ "routedVolume" - refers to single counted shares matched from executions on IEX
  , statsRecentGetResponseMarketShare :: !(Maybe Double) -- ^ "marketShare" - refers to IEX&#39;s percentage of total US Equity market volume
  , statsRecentGetResponseIsHalfday :: !(Maybe Bool) -- ^ "isHalfday" - will be true if the trading day is a half day
  , statsRecentGetResponseLitVolume :: !(Maybe Double) -- ^ "litVolume" - refers to the number of lit shares traded on IEX (single-counted)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatsRecentGetResponse
instance A.FromJSON StatsRecentGetResponse where
  parseJSON = A.withObject "StatsRecentGetResponse" $ \o ->
    StatsRecentGetResponse
      <$> (o .:? "date")
      <*> (o .:? "volume")
      <*> (o .:? "routedVolume")
      <*> (o .:? "marketShare")
      <*> (o .:? "isHalfday")
      <*> (o .:? "litVolume")

-- | ToJSON StatsRecentGetResponse
instance A.ToJSON StatsRecentGetResponse where
  toJSON StatsRecentGetResponse {..} = _omitNulls
    [ "date" .= statsRecentGetResponseDate
    , "volume" .= statsRecentGetResponseVolume
    , "routedVolume" .= statsRecentGetResponseRoutedVolume
    , "marketShare" .= statsRecentGetResponseMarketShare
    , "isHalfday" .= statsRecentGetResponseIsHalfday
    , "litVolume" .= statsRecentGetResponseLitVolume
    ]


-- | Construct a value of type 'StatsRecentGetResponse' (by applying it's required fields, if any)
mkStatsRecentGetResponse :: StatsRecentGetResponse
mkStatsRecentGetResponse = StatsRecentGetResponse
  { statsRecentGetResponseDate         = Nothing
  , statsRecentGetResponseVolume       = Nothing
  , statsRecentGetResponseRoutedVolume = Nothing
  , statsRecentGetResponseMarketShare  = Nothing
  , statsRecentGetResponseIsHalfday    = Nothing
  , statsRecentGetResponseLitVolume    = Nothing
  }

-- ** StatsRecordsGetResponse
-- | StatsRecordsGetResponse
-- * volume refers to single counted shares matched from executions on IEX * symbolsTraded refers to number of symbols traded on IEX * routedVolume refers to executions received from an order routed to away trading centers * notional refers to sum of matched volume times execution price of those trades 
data StatsRecordsGetResponse = StatsRecordsGetResponse
  { statsRecordsGetResponseVolume :: !(Maybe RecordedValue) -- ^ "volume"
  , statsRecordsGetResponseSymbolsTraded :: !(Maybe RecordedValue) -- ^ "symbolsTraded"
  , statsRecordsGetResponseRoutedVolume :: !(Maybe RecordedValue) -- ^ "routedVolume"
  , statsRecordsGetResponseNotional :: !(Maybe RecordedValue) -- ^ "notional"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatsRecordsGetResponse
instance A.FromJSON StatsRecordsGetResponse where
  parseJSON = A.withObject "StatsRecordsGetResponse" $ \o ->
    StatsRecordsGetResponse
      <$> (o .:? "volume")
      <*> (o .:? "symbolsTraded")
      <*> (o .:? "routedVolume")
      <*> (o .:? "notional")

-- | ToJSON StatsRecordsGetResponse
instance A.ToJSON StatsRecordsGetResponse where
  toJSON StatsRecordsGetResponse {..} = _omitNulls
    [ "volume" .= statsRecordsGetResponseVolume
    , "symbolsTraded" .= statsRecordsGetResponseSymbolsTraded
    , "routedVolume" .= statsRecordsGetResponseRoutedVolume
    , "notional" .= statsRecordsGetResponseNotional
    ]


-- | Construct a value of type 'StatsRecordsGetResponse' (by applying it's required fields, if any)
mkStatsRecordsGetResponse :: StatsRecordsGetResponse
mkStatsRecordsGetResponse = StatsRecordsGetResponse
  { statsRecordsGetResponseVolume        = Nothing
  , statsRecordsGetResponseSymbolsTraded = Nothing
  , statsRecordsGetResponseRoutedVolume  = Nothing
  , statsRecordsGetResponseNotional      = Nothing
  }

-- ** MarketGetResponse
-- | MarketGetResponse
data MarketGetResponse = MarketGetResponse
  { marketGetResponseMic :: !(Maybe Text) -- ^ "mic" - refers to the Market Identifier Code (MIC)
  , marketGetResponseTapeId :: !(Maybe Text) -- ^ "tapeId" - refers to the tape id of the venue
  , marketGetResponseVenueName :: !(Maybe Text) -- ^ "venueName" - refers to name of the venue defined by IEX
  , marketGetResponseVolume :: !(Maybe Double) -- ^ "volume" - refers to the amount of traded shares reported by the venue
  , marketGetResponseTapeA :: !(Maybe Double) -- ^ "tapeA" - refers to the amount of Tape A traded shares reported by the venue
  , marketGetResponseTapeB :: !(Maybe Double) -- ^ "tapeB" - refers to the amount of Tape B traded shares reported by the venue
  , marketGetResponseTapeC :: !(Maybe Double) -- ^ "tapeC" - refers to the amount of Tape C traded shares reported by the venue
  , marketGetResponseMarketPercent :: !(Maybe Double) -- ^ "marketPercent" - refers to the venue&#39;s percentage of shares traded in the market
  , marketGetResponseLastUpdated :: !(Maybe Double) -- ^ "lastUpdated" - refers to the last update time of the data in milliseconds since midnight Jan 1, 1970 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MarketGetResponse
instance A.FromJSON MarketGetResponse where
  parseJSON = A.withObject "MarketGetResponse" $ \o ->
    MarketGetResponse
      <$> (o .:? "mic")
      <*> (o .:? "tapeId")
      <*> (o .:? "venueName")
      <*> (o .:? "volume")
      <*> (o .:? "tapeA")
      <*> (o .:? "tapeB")
      <*> (o .:? "tapeC")
      <*> (o .:? "marketPercent")
      <*> (o .:? "lastUpdated")

-- | ToJSON MarketGetResponse
instance A.ToJSON MarketGetResponse where
  toJSON MarketGetResponse {..} = _omitNulls
    [ "mic" .= marketGetResponseMic
    , "tapeId" .= marketGetResponseTapeId
    , "venueName" .= marketGetResponseVenueName
    , "volume" .= marketGetResponseVolume
    , "tapeA" .= marketGetResponseTapeA
    , "tapeB" .= marketGetResponseTapeB
    , "tapeC" .= marketGetResponseTapeC
    , "marketPercent" .= marketGetResponseMarketPercent
    , "lastUpdated" .= marketGetResponseLastUpdated
    ]


-- | Construct a value of type 'MarketGetResponse' (by applying it's required fields, if any)
mkMarketGetResponse :: MarketGetResponse
mkMarketGetResponse = MarketGetResponse
  { marketGetResponseMic           = Nothing
  , marketGetResponseTapeId        = Nothing
  , marketGetResponseVenueName     = Nothing
  , marketGetResponseVolume        = Nothing
  , marketGetResponseTapeA         = Nothing
  , marketGetResponseTapeB         = Nothing
  , marketGetResponseTapeC         = Nothing
  , marketGetResponseMarketPercent = Nothing
  , marketGetResponseLastUpdated   = Nothing
  }

-- ** RefDataSymbolsGetResponse
-- | RefDataSymbolsGetResponse
data RefDataSymbolsGetResponse = RefDataSymbolsGetResponse
  { refDataSymbolsGetResponseSymbol :: !(Maybe Text) -- ^ "symbol" - Refers to the symbol represented in Nasdaq Integrated symbology (INET)
  , refDataSymbolsGetResponseName :: !(Maybe Text) -- ^ "name" - REturns the name of the company or security
  , refDataSymbolsGetResponseDate :: !(Maybe Text) -- ^ "date" - refers to the date the symbol reference data was generated
  , refDataSymbolsGetResponseIsEnabled :: !(Maybe Text) -- ^ "isEnabled" - will be true if the symbol is enabled for trading on IEX
  , refDataSymbolsGetResponseType :: !(Maybe E'Type) -- ^ "type" - refers to the common issue type:   * ad &#x3D; ADR   * re &#x3D; REIT   * ce &#x3D; Closed end fund   * si &#x3D; Secondary issue   * lp &#x3D; Limited partnerships   * cs &#x3D; Common stock   * et &#x3D; ETF 
  , refDataSymbolsGetResponseIexId :: !(Maybe Double) -- ^ "iexId" - unique ID applied by IEX to track securities through symbol changes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RefDataSymbolsGetResponse
instance A.FromJSON RefDataSymbolsGetResponse where
  parseJSON = A.withObject "RefDataSymbolsGetResponse" $ \o ->
    RefDataSymbolsGetResponse
      <$> (o .:? "symbol")
      <*> (o .:? "name")
      <*> (o .:? "date")
      <*> (o .:? "isEnabled")
      <*> (o .:? "type")
      <*> (o .:? "iexId")

-- | ToJSON RefDataSymbolsGetResponse
instance A.ToJSON RefDataSymbolsGetResponse where
  toJSON RefDataSymbolsGetResponse {..} = _omitNulls
    [ "symbol" .= refDataSymbolsGetResponseSymbol
    , "name" .= refDataSymbolsGetResponseName
    , "date" .= refDataSymbolsGetResponseDate
    , "isEnabled" .= refDataSymbolsGetResponseIsEnabled
    , "type" .= refDataSymbolsGetResponseType
    , "iexId" .= refDataSymbolsGetResponseIexId
    ]


-- | Construct a value of type 'RefDataSymbolsGetResponse' (by applying it's required fields, if any)
mkRefDataSymbolsGetResponse :: RefDataSymbolsGetResponse
mkRefDataSymbolsGetResponse = RefDataSymbolsGetResponse
  { refDataSymbolsGetResponseSymbol    = Nothing
  , refDataSymbolsGetResponseName      = Nothing
  , refDataSymbolsGetResponseDate      = Nothing
  , refDataSymbolsGetResponseIsEnabled = Nothing
  , refDataSymbolsGetResponseType      = Nothing
  , refDataSymbolsGetResponseIexId     = Nothing
  }

-- ** StockSymbolBookGetResponse
-- | StockSymbolBookGetResponse
data StockSymbolBookGetResponse = StockSymbolBookGetResponse
  { stockSymbolBookGetResponseQuote :: !(Maybe Quote) -- ^ "quote"
  , stockSymbolBookGetResponseBids :: !(Maybe [Order]) -- ^ "bids"
  , stockSymbolBookGetResponseAsks :: !(Maybe [Order]) -- ^ "asks"
  , stockSymbolBookGetResponseTrades :: !(Maybe [Trade]) -- ^ "trades"
  , stockSymbolBookGetResponseSystemEvent :: !(Maybe SystemEvent) -- ^ "systemEvent"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolBookGetResponse
instance A.FromJSON StockSymbolBookGetResponse where
  parseJSON = A.withObject "StockSymbolBookGetResponse" $ \o ->
    StockSymbolBookGetResponse
      <$> (o .:? "quote")
      <*> (o .:? "bids")
      <*> (o .:? "asks")
      <*> (o .:? "trades")
      <*> (o .:? "systemEvent")

-- | ToJSON StockSymbolBookGetResponse
instance A.ToJSON StockSymbolBookGetResponse where
  toJSON StockSymbolBookGetResponse {..} = _omitNulls
    [ "quote" .= stockSymbolBookGetResponseQuote
    , "bids" .= stockSymbolBookGetResponseBids
    , "asks" .= stockSymbolBookGetResponseAsks
    , "trades" .= stockSymbolBookGetResponseTrades
    , "systemEvent" .= stockSymbolBookGetResponseSystemEvent
    ]


-- | Construct a value of type 'StockSymbolBookGetResponse' (by applying it's required fields, if any)
mkStockSymbolBookGetResponse :: StockSymbolBookGetResponse
mkStockSymbolBookGetResponse = StockSymbolBookGetResponse
  { stockSymbolBookGetResponseQuote       = Nothing
  , stockSymbolBookGetResponseBids        = Nothing
  , stockSymbolBookGetResponseAsks        = Nothing
  , stockSymbolBookGetResponseTrades      = Nothing
  , stockSymbolBookGetResponseSystemEvent = Nothing
  }

-- ** StockSymbolChartDynamicGetResponse
-- | StockSymbolChartDynamicGetResponse
data StockSymbolChartDynamicGetResponse = StockSymbolChartDynamicGetResponse
  { stockSymbolChartDynamicGetResponseRange :: !(Maybe E'Range) -- ^ "range"
  , stockSymbolChartDynamicGetResponseData :: !(Maybe [ChartAll]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolChartDynamicGetResponse
instance A.FromJSON StockSymbolChartDynamicGetResponse where
  parseJSON = A.withObject "StockSymbolChartDynamicGetResponse" $ \o ->
    StockSymbolChartDynamicGetResponse <$> (o .:? "range") <*> (o .:? "data")

-- | ToJSON StockSymbolChartDynamicGetResponse
instance A.ToJSON StockSymbolChartDynamicGetResponse where
  toJSON StockSymbolChartDynamicGetResponse {..} = _omitNulls
    [ "range" .= stockSymbolChartDynamicGetResponseRange
    , "data" .= stockSymbolChartDynamicGetResponseData
    ]


-- | Construct a value of type 'StockSymbolChartDynamicGetResponse' (by applying it's required fields, if any)
mkStockSymbolChartDynamicGetResponse :: StockSymbolChartDynamicGetResponse
mkStockSymbolChartDynamicGetResponse = StockSymbolChartDynamicGetResponse
  { stockSymbolChartDynamicGetResponseRange = Nothing
  , stockSymbolChartDynamicGetResponseData  = Nothing
  }

-- ** StockSymbolCompanyGetResponse
-- | StockSymbolCompanyGetResponse
data StockSymbolCompanyGetResponse = StockSymbolCompanyGetResponse
  { stockSymbolCompanyGetResponseSymbol :: !(Maybe Text) -- ^ "symbol"
  , stockSymbolCompanyGetResponseCompanyName :: !(Maybe Text) -- ^ "companyName"
  , stockSymbolCompanyGetResponseExchange :: !(Maybe Text) -- ^ "exchange"
  , stockSymbolCompanyGetResponseIndustry :: !(Maybe Text) -- ^ "industry"
  , stockSymbolCompanyGetResponseWebsite :: !(Maybe Text) -- ^ "website"
  , stockSymbolCompanyGetResponseDescription :: !(Maybe Text) -- ^ "description"
  , stockSymbolCompanyGetResponseCeo :: !(Maybe Text) -- ^ "CEO"
  , stockSymbolCompanyGetResponseIssueType :: !(Maybe E'IssueType) -- ^ "issueType" - refers to the common issue type of the stock \\n * ad - American Depository Receipt (ADRs) * re - Real Estate Investment Trust (REITs) * ce - Closed end fund (Stock and Bond Fund) * si - Secondary issue * lp - Limited Partnerships * cs - Common Stock * et - Exchange Traded Fund (ETF) * (blank) - Not available, i.e. Warrant, Note, or (non-filing) Closed Ended Funds 
  , stockSymbolCompanyGetResponseSector :: !(Maybe Text) -- ^ "sector"
  , stockSymbolCompanyGetResponseTags :: !(Maybe [Sector]) -- ^ "tags" - an array of strings used to classify the company
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolCompanyGetResponse
instance A.FromJSON StockSymbolCompanyGetResponse where
  parseJSON = A.withObject "StockSymbolCompanyGetResponse" $ \o ->
    StockSymbolCompanyGetResponse
      <$> (o .:? "symbol")
      <*> (o .:? "companyName")
      <*> (o .:? "exchange")
      <*> (o .:? "industry")
      <*> (o .:? "website")
      <*> (o .:? "description")
      <*> (o .:? "CEO")
      <*> (o .:? "issueType")
      <*> (o .:? "sector")
      <*> (o .:? "tags")

-- | ToJSON StockSymbolCompanyGetResponse
instance A.ToJSON StockSymbolCompanyGetResponse where
  toJSON StockSymbolCompanyGetResponse {..} = _omitNulls
    [ "symbol" .= stockSymbolCompanyGetResponseSymbol
    , "companyName" .= stockSymbolCompanyGetResponseCompanyName
    , "exchange" .= stockSymbolCompanyGetResponseExchange
    , "industry" .= stockSymbolCompanyGetResponseIndustry
    , "website" .= stockSymbolCompanyGetResponseWebsite
    , "description" .= stockSymbolCompanyGetResponseDescription
    , "CEO" .= stockSymbolCompanyGetResponseCeo
    , "issueType" .= stockSymbolCompanyGetResponseIssueType
    , "sector" .= stockSymbolCompanyGetResponseSector
    , "tags" .= stockSymbolCompanyGetResponseTags
    ]


-- | Construct a value of type 'StockSymbolCompanyGetResponse' (by applying it's required fields, if any)
mkStockSymbolCompanyGetResponse :: StockSymbolCompanyGetResponse
mkStockSymbolCompanyGetResponse = StockSymbolCompanyGetResponse
  { stockSymbolCompanyGetResponseSymbol      = Nothing
  , stockSymbolCompanyGetResponseCompanyName = Nothing
  , stockSymbolCompanyGetResponseExchange    = Nothing
  , stockSymbolCompanyGetResponseIndustry    = Nothing
  , stockSymbolCompanyGetResponseWebsite     = Nothing
  , stockSymbolCompanyGetResponseDescription = Nothing
  , stockSymbolCompanyGetResponseCeo         = Nothing
  , stockSymbolCompanyGetResponseIssueType   = Nothing
  , stockSymbolCompanyGetResponseSector      = Nothing
  , stockSymbolCompanyGetResponseTags        = Nothing
  }

-- ** StockSymbolDelayedQuoteGetResponse
-- | StockSymbolDelayedQuoteGetResponse
data StockSymbolDelayedQuoteGetResponse = StockSymbolDelayedQuoteGetResponse
  { stockSymbolDelayedQuoteGetResponseSymbol :: !(Maybe Text) -- ^ "symbol"
  , stockSymbolDelayedQuoteGetResponseDelayedPrice :: !(Maybe Double) -- ^ "delayedPrice"
  , stockSymbolDelayedQuoteGetResponseDelayedSize :: !(Maybe Double) -- ^ "delayedSize"
  , stockSymbolDelayedQuoteGetResponseDelayedPriceTime :: !(Maybe Double) -- ^ "delayedPriceTime"
  , stockSymbolDelayedQuoteGetResponseProcessedTime :: !(Maybe Double) -- ^ "processedTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolDelayedQuoteGetResponse
instance A.FromJSON StockSymbolDelayedQuoteGetResponse where
  parseJSON = A.withObject "StockSymbolDelayedQuoteGetResponse" $ \o ->
    StockSymbolDelayedQuoteGetResponse
      <$> (o .:? "symbol")
      <*> (o .:? "delayedPrice")
      <*> (o .:? "delayedSize")
      <*> (o .:? "delayedPriceTime")
      <*> (o .:? "processedTime")

-- | ToJSON StockSymbolDelayedQuoteGetResponse
instance A.ToJSON StockSymbolDelayedQuoteGetResponse where
  toJSON StockSymbolDelayedQuoteGetResponse {..} = _omitNulls
    [ "symbol" .= stockSymbolDelayedQuoteGetResponseSymbol
    , "delayedPrice" .= stockSymbolDelayedQuoteGetResponseDelayedPrice
    , "delayedSize" .= stockSymbolDelayedQuoteGetResponseDelayedSize
    , "delayedPriceTime" .= stockSymbolDelayedQuoteGetResponseDelayedPriceTime
    , "processedTime" .= stockSymbolDelayedQuoteGetResponseProcessedTime
    ]


-- | Construct a value of type 'StockSymbolDelayedQuoteGetResponse' (by applying it's required fields, if any)
mkStockSymbolDelayedQuoteGetResponse :: StockSymbolDelayedQuoteGetResponse
mkStockSymbolDelayedQuoteGetResponse = StockSymbolDelayedQuoteGetResponse
  { stockSymbolDelayedQuoteGetResponseSymbol           = Nothing
  , stockSymbolDelayedQuoteGetResponseDelayedPrice     = Nothing
  , stockSymbolDelayedQuoteGetResponseDelayedSize      = Nothing
  , stockSymbolDelayedQuoteGetResponseDelayedPriceTime = Nothing
  , stockSymbolDelayedQuoteGetResponseProcessedTime    = Nothing
  }

-- ** DeepGetResponseAuction
-- | DeepGetResponseAuction
data DeepGetResponseAuction = DeepGetResponseAuction
  { deepGetResponseAuctionAuctionType :: !(Maybe Text) -- ^ "auctionType"
  , deepGetResponseAuctionPairedShares :: !(Maybe Double) -- ^ "pairedShares"
  , deepGetResponseAuctionImbalanceShares :: !(Maybe Double) -- ^ "imbalanceShares"
  , deepGetResponseAuctionReferencePrice :: !(Maybe Double) -- ^ "referencePrice"
  , deepGetResponseAuctionIndicativePrice :: !(Maybe Double) -- ^ "indicativePrice"
  , deepGetResponseAuctionAuctionBookProce :: !(Maybe Double) -- ^ "auctionBookProce"
  , deepGetResponseAuctionCollarReferencePrice :: !(Maybe Double) -- ^ "collarReferencePrice"
  , deepGetResponseAuctionLowerCollarPrice :: !(Maybe Double) -- ^ "lowerCollarPrice"
  , deepGetResponseAuctionUpperCollarPrice :: !(Maybe Double) -- ^ "upperCollarPrice"
  , deepGetResponseAuctionExtensionNumber :: !(Maybe Double) -- ^ "extensionNumber"
  , deepGetResponseAuctionStartTime :: !(Maybe Text) -- ^ "startTime"
  , deepGetResponseAuctionLastUpdate :: !(Maybe Double) -- ^ "lastUpdate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepGetResponseAuction
instance A.FromJSON DeepGetResponseAuction where
  parseJSON = A.withObject "DeepGetResponseAuction" $ \o ->
    DeepGetResponseAuction
      <$> (o .:? "auctionType")
      <*> (o .:? "pairedShares")
      <*> (o .:? "imbalanceShares")
      <*> (o .:? "referencePrice")
      <*> (o .:? "indicativePrice")
      <*> (o .:? "auctionBookProce")
      <*> (o .:? "collarReferencePrice")
      <*> (o .:? "lowerCollarPrice")
      <*> (o .:? "upperCollarPrice")
      <*> (o .:? "extensionNumber")
      <*> (o .:? "startTime")
      <*> (o .:? "lastUpdate")

-- | ToJSON DeepGetResponseAuction
instance A.ToJSON DeepGetResponseAuction where
  toJSON DeepGetResponseAuction {..} = _omitNulls
    [ "auctionType" .= deepGetResponseAuctionAuctionType
    , "pairedShares" .= deepGetResponseAuctionPairedShares
    , "imbalanceShares" .= deepGetResponseAuctionImbalanceShares
    , "referencePrice" .= deepGetResponseAuctionReferencePrice
    , "indicativePrice" .= deepGetResponseAuctionIndicativePrice
    , "auctionBookProce" .= deepGetResponseAuctionAuctionBookProce
    , "collarReferencePrice" .= deepGetResponseAuctionCollarReferencePrice
    , "lowerCollarPrice" .= deepGetResponseAuctionLowerCollarPrice
    , "upperCollarPrice" .= deepGetResponseAuctionUpperCollarPrice
    , "extensionNumber" .= deepGetResponseAuctionExtensionNumber
    , "startTime" .= deepGetResponseAuctionStartTime
    , "lastUpdate" .= deepGetResponseAuctionLastUpdate
    ]


-- | Construct a value of type 'DeepGetResponseAuction' (by applying it's required fields, if any)
mkDeepGetResponseAuction :: DeepGetResponseAuction
mkDeepGetResponseAuction = DeepGetResponseAuction
  { deepGetResponseAuctionAuctionType          = Nothing
  , deepGetResponseAuctionPairedShares         = Nothing
  , deepGetResponseAuctionImbalanceShares      = Nothing
  , deepGetResponseAuctionReferencePrice       = Nothing
  , deepGetResponseAuctionIndicativePrice      = Nothing
  , deepGetResponseAuctionAuctionBookProce     = Nothing
  , deepGetResponseAuctionCollarReferencePrice = Nothing
  , deepGetResponseAuctionLowerCollarPrice     = Nothing
  , deepGetResponseAuctionUpperCollarPrice     = Nothing
  , deepGetResponseAuctionExtensionNumber      = Nothing
  , deepGetResponseAuctionStartTime            = Nothing
  , deepGetResponseAuctionLastUpdate           = Nothing
  }

-- ** DeepGetResponseOpHaltStatus
-- | DeepGetResponseOpHaltStatus
data DeepGetResponseOpHaltStatus = DeepGetResponseOpHaltStatus
  { deepGetResponseOpHaltStatusIsHalted :: !(Maybe Bool) -- ^ "isHalted"
  , deepGetResponseOpHaltStatusTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepGetResponseOpHaltStatus
instance A.FromJSON DeepGetResponseOpHaltStatus where
  parseJSON = A.withObject "DeepGetResponseOpHaltStatus" $ \o ->
    DeepGetResponseOpHaltStatus <$> (o .:? "isHalted") <*> (o .:? "timestamp")

-- | ToJSON DeepGetResponseOpHaltStatus
instance A.ToJSON DeepGetResponseOpHaltStatus where
  toJSON DeepGetResponseOpHaltStatus {..} = _omitNulls
    [ "isHalted" .= deepGetResponseOpHaltStatusIsHalted
    , "timestamp" .= deepGetResponseOpHaltStatusTimestamp
    ]


-- | Construct a value of type 'DeepGetResponseOpHaltStatus' (by applying it's required fields, if any)
mkDeepGetResponseOpHaltStatus :: DeepGetResponseOpHaltStatus
mkDeepGetResponseOpHaltStatus = DeepGetResponseOpHaltStatus
  { deepGetResponseOpHaltStatusIsHalted  = Nothing
  , deepGetResponseOpHaltStatusTimestamp = Nothing
  }

-- ** DeepGetResponseSecurityEvent
-- | DeepGetResponseSecurityEvent
data DeepGetResponseSecurityEvent = DeepGetResponseSecurityEvent
  { deepGetResponseSecurityEventSecurityEvent :: !(Maybe Text) -- ^ "securityEvent"
  , deepGetResponseSecurityEventTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepGetResponseSecurityEvent
instance A.FromJSON DeepGetResponseSecurityEvent where
  parseJSON = A.withObject "DeepGetResponseSecurityEvent" $ \o ->
    DeepGetResponseSecurityEvent
      <$> (o .:? "securityEvent")
      <*> (o .:? "timestamp")

-- | ToJSON DeepGetResponseSecurityEvent
instance A.ToJSON DeepGetResponseSecurityEvent where
  toJSON DeepGetResponseSecurityEvent {..} = _omitNulls
    [ "securityEvent" .= deepGetResponseSecurityEventSecurityEvent
    , "timestamp" .= deepGetResponseSecurityEventTimestamp
    ]


-- | Construct a value of type 'DeepGetResponseSecurityEvent' (by applying it's required fields, if any)
mkDeepGetResponseSecurityEvent :: DeepGetResponseSecurityEvent
mkDeepGetResponseSecurityEvent = DeepGetResponseSecurityEvent
  { deepGetResponseSecurityEventSecurityEvent = Nothing
  , deepGetResponseSecurityEventTimestamp     = Nothing
  }

-- ** DeepGetResponseSsrStatus
-- | DeepGetResponseSsrStatus
data DeepGetResponseSsrStatus = DeepGetResponseSsrStatus
  { deepGetResponseSsrStatusIsSsr :: !(Maybe Bool) -- ^ "isSSR"
  , deepGetResponseSsrStatusDetail :: !(Maybe Text) -- ^ "detail"
  , deepGetResponseSsrStatusTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepGetResponseSsrStatus
instance A.FromJSON DeepGetResponseSsrStatus where
  parseJSON = A.withObject "DeepGetResponseSsrStatus" $ \o ->
    DeepGetResponseSsrStatus
      <$> (o .:? "isSSR")
      <*> (o .:? "detail")
      <*> (o .:? "timestamp")

-- | ToJSON DeepGetResponseSsrStatus
instance A.ToJSON DeepGetResponseSsrStatus where
  toJSON DeepGetResponseSsrStatus {..} = _omitNulls
    [ "isSSR" .= deepGetResponseSsrStatusIsSsr
    , "detail" .= deepGetResponseSsrStatusDetail
    , "timestamp" .= deepGetResponseSsrStatusTimestamp
    ]


-- | Construct a value of type 'DeepGetResponseSsrStatus' (by applying it's required fields, if any)
mkDeepGetResponseSsrStatus :: DeepGetResponseSsrStatus
mkDeepGetResponseSsrStatus = DeepGetResponseSsrStatus
  { deepGetResponseSsrStatusIsSsr     = Nothing
  , deepGetResponseSsrStatusDetail    = Nothing
  , deepGetResponseSsrStatusTimestamp = Nothing
  }

-- ** DeepGetResponseTradeBreaks
-- | DeepGetResponseTradeBreaks
data DeepGetResponseTradeBreaks = DeepGetResponseTradeBreaks
  { deepGetResponseTradeBreaksPrice :: !(Maybe Double) -- ^ "price"
  , deepGetResponseTradeBreaksSize :: !(Maybe Double) -- ^ "size"
  , deepGetResponseTradeBreaksTradeId :: !(Maybe Double) -- ^ "tradeId"
  , deepGetResponseTradeBreaksIsIso :: !(Maybe Bool) -- ^ "isISO"
  , deepGetResponseTradeBreaksIsOddLot :: !(Maybe Bool) -- ^ "isOddLot"
  , deepGetResponseTradeBreaksIsOutsideRegularHours :: !(Maybe Bool) -- ^ "isOutsideRegularHours"
  , deepGetResponseTradeBreaksIsSinglePriceCross :: !(Maybe Bool) -- ^ "isSinglePriceCross"
  , deepGetResponseTradeBreaksIsTradeThroughExempt :: !(Maybe Bool) -- ^ "isTradeThroughExempt"
  , deepGetResponseTradeBreaksTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepGetResponseTradeBreaks
instance A.FromJSON DeepGetResponseTradeBreaks where
  parseJSON = A.withObject "DeepGetResponseTradeBreaks" $ \o ->
    DeepGetResponseTradeBreaks
      <$> (o .:? "price")
      <*> (o .:? "size")
      <*> (o .:? "tradeId")
      <*> (o .:? "isISO")
      <*> (o .:? "isOddLot")
      <*> (o .:? "isOutsideRegularHours")
      <*> (o .:? "isSinglePriceCross")
      <*> (o .:? "isTradeThroughExempt")
      <*> (o .:? "timestamp")

-- | ToJSON DeepGetResponseTradeBreaks
instance A.ToJSON DeepGetResponseTradeBreaks where
  toJSON DeepGetResponseTradeBreaks {..} = _omitNulls
    [ "price" .= deepGetResponseTradeBreaksPrice
    , "size" .= deepGetResponseTradeBreaksSize
    , "tradeId" .= deepGetResponseTradeBreaksTradeId
    , "isISO" .= deepGetResponseTradeBreaksIsIso
    , "isOddLot" .= deepGetResponseTradeBreaksIsOddLot
    , "isOutsideRegularHours" .= deepGetResponseTradeBreaksIsOutsideRegularHours
    , "isSinglePriceCross" .= deepGetResponseTradeBreaksIsSinglePriceCross
    , "isTradeThroughExempt" .= deepGetResponseTradeBreaksIsTradeThroughExempt
    , "timestamp" .= deepGetResponseTradeBreaksTimestamp
    ]


-- | Construct a value of type 'DeepGetResponseTradeBreaks' (by applying it's required fields, if any)
mkDeepGetResponseTradeBreaks :: DeepGetResponseTradeBreaks
mkDeepGetResponseTradeBreaks = DeepGetResponseTradeBreaks
  { deepGetResponseTradeBreaksPrice                 = Nothing
  , deepGetResponseTradeBreaksSize                  = Nothing
  , deepGetResponseTradeBreaksTradeId               = Nothing
  , deepGetResponseTradeBreaksIsIso                 = Nothing
  , deepGetResponseTradeBreaksIsOddLot              = Nothing
  , deepGetResponseTradeBreaksIsOutsideRegularHours = Nothing
  , deepGetResponseTradeBreaksIsSinglePriceCross    = Nothing
  , deepGetResponseTradeBreaksIsTradeThroughExempt  = Nothing
  , deepGetResponseTradeBreaksTimestamp             = Nothing
  }

-- ** DeepGetResponseTradingStatus
-- | DeepGetResponseTradingStatus
data DeepGetResponseTradingStatus = DeepGetResponseTradingStatus
  { deepGetResponseTradingStatusStatus :: !(Maybe Text) -- ^ "status"
  , deepGetResponseTradingStatusReason :: !(Maybe Text) -- ^ "reason"
  , deepGetResponseTradingStatusTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepGetResponseTradingStatus
instance A.FromJSON DeepGetResponseTradingStatus where
  parseJSON = A.withObject "DeepGetResponseTradingStatus" $ \o ->
    DeepGetResponseTradingStatus
      <$> (o .:? "status")
      <*> (o .:? "reason")
      <*> (o .:? "timestamp")

-- | ToJSON DeepGetResponseTradingStatus
instance A.ToJSON DeepGetResponseTradingStatus where
  toJSON DeepGetResponseTradingStatus {..} = _omitNulls
    [ "status" .= deepGetResponseTradingStatusStatus
    , "reason" .= deepGetResponseTradingStatusReason
    , "timestamp" .= deepGetResponseTradingStatusTimestamp
    ]


-- | Construct a value of type 'DeepGetResponseTradingStatus' (by applying it's required fields, if any)
mkDeepGetResponseTradingStatus :: DeepGetResponseTradingStatus
mkDeepGetResponseTradingStatus = DeepGetResponseTradingStatus
  { deepGetResponseTradingStatusStatus    = Nothing
  , deepGetResponseTradingStatusReason    = Nothing
  , deepGetResponseTradingStatusTimestamp = Nothing
  }

-- ** HistGetResponse
-- | HistGetResponse
data HistGetResponse = HistGetResponse
  { histGetResponseLink :: !(Maybe Text) -- ^ "link"
  , histGetResponseDate :: !(Maybe Text) -- ^ "date"
  , histGetResponseFeed :: !(Maybe Text) -- ^ "feed"
  , histGetResponseVersion :: !(Maybe Text) -- ^ "version"
  , histGetResponseProtocol :: !(Maybe Text) -- ^ "protocol"
  , histGetResponseSize :: !(Maybe Text) -- ^ "size"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HistGetResponse
instance A.FromJSON HistGetResponse where
  parseJSON = A.withObject "HistGetResponse" $ \o ->
    HistGetResponse
      <$> (o .:? "link")
      <*> (o .:? "date")
      <*> (o .:? "feed")
      <*> (o .:? "version")
      <*> (o .:? "protocol")
      <*> (o .:? "size")

-- | ToJSON HistGetResponse
instance A.ToJSON HistGetResponse where
  toJSON HistGetResponse {..} = _omitNulls
    [ "link" .= histGetResponseLink
    , "date" .= histGetResponseDate
    , "feed" .= histGetResponseFeed
    , "version" .= histGetResponseVersion
    , "protocol" .= histGetResponseProtocol
    , "size" .= histGetResponseSize
    ]


-- | Construct a value of type 'HistGetResponse' (by applying it's required fields, if any)
mkHistGetResponse :: HistGetResponse
mkHistGetResponse = HistGetResponse { histGetResponseLink     = Nothing
                                    , histGetResponseDate     = Nothing
                                    , histGetResponseFeed     = Nothing
                                    , histGetResponseVersion  = Nothing
                                    , histGetResponseProtocol = Nothing
                                    , histGetResponseSize     = Nothing
                                    }

-- ** StockSymbolDividendsRangeGetResponse
-- | StockSymbolDividendsRangeGetResponse
data StockSymbolDividendsRangeGetResponse = StockSymbolDividendsRangeGetResponse
  { stockSymbolDividendsRangeGetResponseExDate :: !(Maybe Text) -- ^ "exDate" - Refers to the dividend ex-date
  , stockSymbolDividendsRangeGetResponsePaymentDate :: !(Maybe Text) -- ^ "paymentDate" - Refers to the payment date
  , stockSymbolDividendsRangeGetResponseRecordDate :: !(Maybe Text) -- ^ "recordDate" - Refers to the dividend record date
  , stockSymbolDividendsRangeGetResponseDeclaredDate :: !(Maybe Text) -- ^ "declaredDate" - Refers to the dividend declaration date
  , stockSymbolDividendsRangeGetResponseAmount :: !(Maybe Double) -- ^ "amount" - Refers to the payment amount
  , stockSymbolDividendsRangeGetResponseFlag :: !(Maybe E'Flag) -- ^ "flag" - Refers to the dividend flag:   * LI &#x3D; Liquidation, instrument liquidates   * PR &#x3D; Proceeds of a sale of rights or shares   * RE &#x3D; Redemption of rights   * AC &#x3D; Accrued dividend   * AR &#x3D; Payment in arrears   * AD &#x3D; Additional payment   * EX &#x3D; Extra payment   * SP &#x3D; Special dividend   * YE &#x3D; Year end   * UR &#x3D; Unknown recordDate   * SU &#x3D; Regular divdend is suspended 
  , stockSymbolDividendsRangeGetResponseType :: !(Maybe E'Type2) -- ^ "type" - Refers to the dividend payment type 
  , stockSymbolDividendsRangeGetResponseQualified :: !(Maybe E'Qualified) -- ^ "qualified" - Refers to the dividend income type:   * P &#x3D; Partially qualified income   * Q &#x3D; Qualified income   * N &#x3D; Unqualified income   * null &#x3D; N/A or unknown 
  , stockSymbolDividendsRangeGetResponseIndicated :: !(Maybe Double) -- ^ "indicated" - Refers to the indicated rate of the dividend
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolDividendsRangeGetResponse
instance A.FromJSON StockSymbolDividendsRangeGetResponse where
  parseJSON = A.withObject "StockSymbolDividendsRangeGetResponse" $ \o ->
    StockSymbolDividendsRangeGetResponse
      <$> (o .:? "exDate")
      <*> (o .:? "paymentDate")
      <*> (o .:? "recordDate")
      <*> (o .:? "declaredDate")
      <*> (o .:? "amount")
      <*> (o .:? "flag")
      <*> (o .:? "type")
      <*> (o .:? "qualified")
      <*> (o .:? "indicated")

-- | ToJSON StockSymbolDividendsRangeGetResponse
instance A.ToJSON StockSymbolDividendsRangeGetResponse where
  toJSON StockSymbolDividendsRangeGetResponse {..} = _omitNulls
    [ "exDate" .= stockSymbolDividendsRangeGetResponseExDate
    , "paymentDate" .= stockSymbolDividendsRangeGetResponsePaymentDate
    , "recordDate" .= stockSymbolDividendsRangeGetResponseRecordDate
    , "declaredDate" .= stockSymbolDividendsRangeGetResponseDeclaredDate
    , "amount" .= stockSymbolDividendsRangeGetResponseAmount
    , "flag" .= stockSymbolDividendsRangeGetResponseFlag
    , "type" .= stockSymbolDividendsRangeGetResponseType
    , "qualified" .= stockSymbolDividendsRangeGetResponseQualified
    , "indicated" .= stockSymbolDividendsRangeGetResponseIndicated
    ]


-- | Construct a value of type 'StockSymbolDividendsRangeGetResponse' (by applying it's required fields, if any)
mkStockSymbolDividendsRangeGetResponse :: StockSymbolDividendsRangeGetResponse
mkStockSymbolDividendsRangeGetResponse = StockSymbolDividendsRangeGetResponse
  { stockSymbolDividendsRangeGetResponseExDate       = Nothing
  , stockSymbolDividendsRangeGetResponsePaymentDate  = Nothing
  , stockSymbolDividendsRangeGetResponseRecordDate   = Nothing
  , stockSymbolDividendsRangeGetResponseDeclaredDate = Nothing
  , stockSymbolDividendsRangeGetResponseAmount       = Nothing
  , stockSymbolDividendsRangeGetResponseFlag         = Nothing
  , stockSymbolDividendsRangeGetResponseType         = Nothing
  , stockSymbolDividendsRangeGetResponseQualified    = Nothing
  , stockSymbolDividendsRangeGetResponseIndicated    = Nothing
  }

-- ** StockSymbolEarningsGetResponse
-- | StockSymbolEarningsGetResponse
data StockSymbolEarningsGetResponse = StockSymbolEarningsGetResponse
  { stockSymbolEarningsGetResponseSymbol :: !(Maybe Text) -- ^ "symbol"
  , stockSymbolEarningsGetResponseEarnings :: !(Maybe [Earnings]) -- ^ "earnings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolEarningsGetResponse
instance A.FromJSON StockSymbolEarningsGetResponse where
  parseJSON = A.withObject "StockSymbolEarningsGetResponse" $ \o ->
    StockSymbolEarningsGetResponse <$> (o .:? "symbol") <*> (o .:? "earnings")

-- | ToJSON StockSymbolEarningsGetResponse
instance A.ToJSON StockSymbolEarningsGetResponse where
  toJSON StockSymbolEarningsGetResponse {..} = _omitNulls
    [ "symbol" .= stockSymbolEarningsGetResponseSymbol
    , "earnings" .= stockSymbolEarningsGetResponseEarnings
    ]


-- | Construct a value of type 'StockSymbolEarningsGetResponse' (by applying it's required fields, if any)
mkStockSymbolEarningsGetResponse :: StockSymbolEarningsGetResponse
mkStockSymbolEarningsGetResponse = StockSymbolEarningsGetResponse
  { stockSymbolEarningsGetResponseSymbol   = Nothing
  , stockSymbolEarningsGetResponseEarnings = Nothing
  }

-- ** StockSymbolEffectiveSpreadGetResponse
-- | StockSymbolEffectiveSpreadGetResponse
data StockSymbolEffectiveSpreadGetResponse = StockSymbolEffectiveSpreadGetResponse
  { stockSymbolEffectiveSpreadGetResponseVolume :: !(Maybe Double) -- ^ "volume" - Refers to the eligible shares used for calculating &#x60;effectiveSpread&#x60; and &#x60;priceImprovement&#x60;
  , stockSymbolEffectiveSpreadGetResponseVenue :: !(Maybe Text) -- ^ "venue" - refers to the Market Identifier Code (MIC)
  , stockSymbolEffectiveSpreadGetResponseVenueName :: !(Maybe Text) -- ^ "venueName" - Refers to a readable version of the venue defined by IEX
  , stockSymbolEffectiveSpreadGetResponseEffectiveSpread :: !(Maybe Double) -- ^ "effectiveSpread" - is designed to measure marketable orders executed in relation to the market center&#39;s quoted spread and takes into account hidden and midpoint liquidity available at each market center in dollars
  , stockSymbolEffectiveSpreadGetResponseEffectiveQuoted :: !(Maybe Double) -- ^ "effectiveQuoted" - a ratio calculated by dividing a market center&#39;s effective spread by the NBBO quoted spread
  , stockSymbolEffectiveSpreadGetResponsePriceImprovement :: !(Maybe Double) -- ^ "priceImprovement" - the average amount of price improvement in dollars per eligible share executed
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolEffectiveSpreadGetResponse
instance A.FromJSON StockSymbolEffectiveSpreadGetResponse where
  parseJSON = A.withObject "StockSymbolEffectiveSpreadGetResponse" $ \o ->
    StockSymbolEffectiveSpreadGetResponse
      <$> (o .:? "volume")
      <*> (o .:? "venue")
      <*> (o .:? "venueName")
      <*> (o .:? "effectiveSpread")
      <*> (o .:? "effectiveQuoted")
      <*> (o .:? "priceImprovement")

-- | ToJSON StockSymbolEffectiveSpreadGetResponse
instance A.ToJSON StockSymbolEffectiveSpreadGetResponse where
  toJSON StockSymbolEffectiveSpreadGetResponse {..} = _omitNulls
    [ "volume" .= stockSymbolEffectiveSpreadGetResponseVolume
    , "venue" .= stockSymbolEffectiveSpreadGetResponseVenue
    , "venueName" .= stockSymbolEffectiveSpreadGetResponseVenueName
    , "effectiveSpread" .= stockSymbolEffectiveSpreadGetResponseEffectiveSpread
    , "effectiveQuoted" .= stockSymbolEffectiveSpreadGetResponseEffectiveQuoted
    , "priceImprovement"
      .= stockSymbolEffectiveSpreadGetResponsePriceImprovement
    ]


-- | Construct a value of type 'StockSymbolEffectiveSpreadGetResponse' (by applying it's required fields, if any)
mkStockSymbolEffectiveSpreadGetResponse :: StockSymbolEffectiveSpreadGetResponse
mkStockSymbolEffectiveSpreadGetResponse = StockSymbolEffectiveSpreadGetResponse
  { stockSymbolEffectiveSpreadGetResponseVolume           = Nothing
  , stockSymbolEffectiveSpreadGetResponseVenue            = Nothing
  , stockSymbolEffectiveSpreadGetResponseVenueName        = Nothing
  , stockSymbolEffectiveSpreadGetResponseEffectiveSpread  = Nothing
  , stockSymbolEffectiveSpreadGetResponseEffectiveQuoted  = Nothing
  , stockSymbolEffectiveSpreadGetResponsePriceImprovement = Nothing
  }

-- ** StockSymbolFinancialsGetResponse
-- | StockSymbolFinancialsGetResponse
data StockSymbolFinancialsGetResponse = StockSymbolFinancialsGetResponse
  { stockSymbolFinancialsGetResponseSymbol :: !(Maybe Text) -- ^ "symbol"
  , stockSymbolFinancialsGetResponseFinancials :: !(Maybe [Financials]) -- ^ "financials"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolFinancialsGetResponse
instance A.FromJSON StockSymbolFinancialsGetResponse where
  parseJSON = A.withObject "StockSymbolFinancialsGetResponse" $ \o ->
    StockSymbolFinancialsGetResponse
      <$> (o .:? "symbol")
      <*> (o .:? "financials")

-- | ToJSON StockSymbolFinancialsGetResponse
instance A.ToJSON StockSymbolFinancialsGetResponse where
  toJSON StockSymbolFinancialsGetResponse {..} = _omitNulls
    [ "symbol" .= stockSymbolFinancialsGetResponseSymbol
    , "financials" .= stockSymbolFinancialsGetResponseFinancials
    ]


-- | Construct a value of type 'StockSymbolFinancialsGetResponse' (by applying it's required fields, if any)
mkStockSymbolFinancialsGetResponse :: StockSymbolFinancialsGetResponse
mkStockSymbolFinancialsGetResponse = StockSymbolFinancialsGetResponse
  { stockSymbolFinancialsGetResponseSymbol     = Nothing
  , stockSymbolFinancialsGetResponseFinancials = Nothing
  }

-- ** StockMarketThresholdSecuritiesGetResponse
-- | StockMarketThresholdSecuritiesGetResponse
data StockMarketThresholdSecuritiesGetResponse = StockMarketThresholdSecuritiesGetResponse
  { stockMarketThresholdSecuritiesGetResponseTradeDate :: !(Maybe Double) -- ^ "TradeDate"
  , stockMarketThresholdSecuritiesGetResponseSymbolinInetSymbology :: !(Maybe Text) -- ^ "SymbolinINETSymbology"
  , stockMarketThresholdSecuritiesGetResponseSymbolinCqsSymbology :: !(Maybe Text) -- ^ "SymbolinCQSSymbology"
  , stockMarketThresholdSecuritiesGetResponseSymbolinCmsSymbology :: !(Maybe Text) -- ^ "SymbolinCMSSymbology"
  , stockMarketThresholdSecuritiesGetResponseSecurityName :: !(Maybe Text) -- ^ "SecurityName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockMarketThresholdSecuritiesGetResponse
instance A.FromJSON StockMarketThresholdSecuritiesGetResponse where
  parseJSON = A.withObject "StockMarketThresholdSecuritiesGetResponse" $ \o ->
    StockMarketThresholdSecuritiesGetResponse
      <$> (o .:? "TradeDate")
      <*> (o .:? "SymbolinINETSymbology")
      <*> (o .:? "SymbolinCQSSymbology")
      <*> (o .:? "SymbolinCMSSymbology")
      <*> (o .:? "SecurityName")

-- | ToJSON StockMarketThresholdSecuritiesGetResponse
instance A.ToJSON StockMarketThresholdSecuritiesGetResponse where
  toJSON StockMarketThresholdSecuritiesGetResponse {..} = _omitNulls
    [ "TradeDate" .= stockMarketThresholdSecuritiesGetResponseTradeDate
    , "SymbolinINETSymbology"
      .= stockMarketThresholdSecuritiesGetResponseSymbolinInetSymbology
    , "SymbolinCQSSymbology"
      .= stockMarketThresholdSecuritiesGetResponseSymbolinCqsSymbology
    , "SymbolinCMSSymbology"
      .= stockMarketThresholdSecuritiesGetResponseSymbolinCmsSymbology
    , "SecurityName" .= stockMarketThresholdSecuritiesGetResponseSecurityName
    ]


-- | Construct a value of type 'StockMarketThresholdSecuritiesGetResponse' (by applying it's required fields, if any)
mkStockMarketThresholdSecuritiesGetResponse
  :: StockMarketThresholdSecuritiesGetResponse
mkStockMarketThresholdSecuritiesGetResponse =
  StockMarketThresholdSecuritiesGetResponse
    { stockMarketThresholdSecuritiesGetResponseTradeDate             = Nothing
    , stockMarketThresholdSecuritiesGetResponseSymbolinInetSymbology = Nothing
    , stockMarketThresholdSecuritiesGetResponseSymbolinCqsSymbology  = Nothing
    , stockMarketThresholdSecuritiesGetResponseSymbolinCmsSymbology  = Nothing
    , stockMarketThresholdSecuritiesGetResponseSecurityName          = Nothing
    }

-- ** StockMarketUpcomingIposGetResponse
-- | StockMarketUpcomingIposGetResponse
data StockMarketUpcomingIposGetResponse = StockMarketUpcomingIposGetResponse
  { stockMarketUpcomingIposGetResponseRawData :: !(Maybe [IpoRawData]) -- ^ "rawData"
  , stockMarketUpcomingIposGetResponseViewData :: !(Maybe [IpoViewData]) -- ^ "viewData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockMarketUpcomingIposGetResponse
instance A.FromJSON StockMarketUpcomingIposGetResponse where
  parseJSON = A.withObject "StockMarketUpcomingIposGetResponse" $ \o ->
    StockMarketUpcomingIposGetResponse
      <$> (o .:? "rawData")
      <*> (o .:? "viewData")

-- | ToJSON StockMarketUpcomingIposGetResponse
instance A.ToJSON StockMarketUpcomingIposGetResponse where
  toJSON StockMarketUpcomingIposGetResponse {..} = _omitNulls
    [ "rawData" .= stockMarketUpcomingIposGetResponseRawData
    , "viewData" .= stockMarketUpcomingIposGetResponseViewData
    ]


-- | Construct a value of type 'StockMarketUpcomingIposGetResponse' (by applying it's required fields, if any)
mkStockMarketUpcomingIposGetResponse :: StockMarketUpcomingIposGetResponse
mkStockMarketUpcomingIposGetResponse = StockMarketUpcomingIposGetResponse
  { stockMarketUpcomingIposGetResponseRawData  = Nothing
  , stockMarketUpcomingIposGetResponseViewData = Nothing
  }

-- ** StockSymbolStatsGetResponse
-- | StockSymbolStatsGetResponse
data StockSymbolStatsGetResponse = StockSymbolStatsGetResponse
  { stockSymbolStatsGetResponseCompanyName :: !(Maybe Text) -- ^ "companyName"
  , stockSymbolStatsGetResponseMarketcap :: !(Maybe Double) -- ^ "marketcap" - Is not calculated in real time
  , stockSymbolStatsGetResponseBeta :: !(Maybe Double) -- ^ "beta"
  , inlineResponse20026Week52high :: !(Maybe Double) -- ^ "week52high"
  , inlineResponse20026Week52low :: !(Maybe Double) -- ^ "week52low"
  , inlineResponse20026Week52change :: !(Maybe Double) -- ^ "week52change"
  , stockSymbolStatsGetResponseShortInterest :: !(Maybe Double) -- ^ "shortInterest"
  , stockSymbolStatsGetResponseShortDate :: !(Maybe Text) -- ^ "shortDate"
  , stockSymbolStatsGetResponseDividendRate :: !(Maybe Double) -- ^ "dividendRate"
  , stockSymbolStatsGetResponseDividendYield :: !(Maybe Double) -- ^ "dividendYield"
  , stockSymbolStatsGetResponseExDividendDate :: !(Maybe Text) -- ^ "exDividendDate"
  , stockSymbolStatsGetResponseLatestEps :: !(Maybe Double) -- ^ "latestEPS" - Most recent quarter
  , stockSymbolStatsGetResponseLatestEpsDate :: !(Maybe Text) -- ^ "latestEPSDate"
  , stockSymbolStatsGetResponseSharesOutstanding :: !(Maybe Double) -- ^ "sharesOutstanding"
  , stockSymbolStatsGetResponseFloat :: !(Maybe Double) -- ^ "float"
  , stockSymbolStatsGetResponseReturnOnEquity :: !(Maybe Double) -- ^ "returnOnEquity" - Trailing twelve months
  , stockSymbolStatsGetResponseConsensusEps :: !(Maybe Double) -- ^ "consensusEPS" - Most recent quarter
  , stockSymbolStatsGetResponseNumberOfEstimates :: !(Maybe Double) -- ^ "numberOfEstimates" - Most recent quarter
  , stockSymbolStatsGetResponseSymbol :: !(Maybe Text) -- ^ "symbol"
  , stockSymbolStatsGetResponseEbitda :: !(Maybe Double) -- ^ "EBITDA" - Trailing twelve months
  , stockSymbolStatsGetResponseRevenue :: !(Maybe Double) -- ^ "revenue" - Trailing twelve months
  , stockSymbolStatsGetResponseGrossProfit :: !(Maybe Double) -- ^ "grossProfit" - Trailing twelve months
  , stockSymbolStatsGetResponseCash :: !(Maybe Double) -- ^ "cash" - Refers to total cash. Trailing twelve months
  , stockSymbolStatsGetResponseDebt :: !(Maybe Double) -- ^ "debt" - Refers to total debt. Trailing twelve months
  , stockSymbolStatsGetResponseTtmEps :: !(Maybe Double) -- ^ "ttmEPS" - Trailing twelve months
  , stockSymbolStatsGetResponseRevenuePerShare :: !(Maybe Double) -- ^ "revenuePerShare" - Trailing twelve months
  , stockSymbolStatsGetResponseRevenuePerEmployee :: !(Maybe Double) -- ^ "revenuePerEmployee" - Trailing twelve months
  , stockSymbolStatsGetResponsePeRatioHigh :: !(Maybe Double) -- ^ "peRatioHigh"
  , stockSymbolStatsGetResponsePeRatioLow :: !(Maybe Double) -- ^ "peRatioLow"
  , stockSymbolStatsGetResponseEpsSurpriseDollar :: !(Maybe Double) -- ^ "EPSSurpriseDollar" - Refers to the difference between actual EPS and consensus EPS in dollars
  , stockSymbolStatsGetResponseEpsSurprisePercent :: !(Maybe Double) -- ^ "EPSSurprisePercent" - Refers to the percent difference between actual EPS and consensus EPS
  , stockSymbolStatsGetResponseReturnOnAssets :: !(Maybe Double) -- ^ "returnOnAssets" - Trailing twelve months
  , stockSymbolStatsGetResponseReturnOnCapital :: !(Maybe Double) -- ^ "returnOnCapital" - Trailing twelve months
  , stockSymbolStatsGetResponseProfitMargin :: !(Maybe Double) -- ^ "profitMargin"
  , stockSymbolStatsGetResponsePriceToSales :: !(Maybe Double) -- ^ "priceToSales"
  , stockSymbolStatsGetResponsePriceToBook :: !(Maybe Double) -- ^ "priceToBook"
  , inlineResponse20026Day200MovingAvg :: !(Maybe Double) -- ^ "day200MovingAvg"
  , inlineResponse20026Day50MovingAvg :: !(Maybe Double) -- ^ "day50MovingAvg"
  , stockSymbolStatsGetResponseInstitutionPercent :: !(Maybe Double) -- ^ "institutionPercent" - Represents top 15 institutions
  , stockSymbolStatsGetResponseInsiderPercent :: !(Maybe Double) -- ^ "insiderPercent"
  , stockSymbolStatsGetResponseShortRatio :: !(Maybe Double) -- ^ "shortRatio"
  , inlineResponse20026Year5ChangePercent :: !(Maybe Double) -- ^ "year5ChangePercent"
  , inlineResponse20026Year2ChangePercent :: !(Maybe Double) -- ^ "year2ChangePercent"
  , inlineResponse20026Year1ChangePercent :: !(Maybe Double) -- ^ "year1ChangePercent"
  , stockSymbolStatsGetResponseYtdChangePercent :: !(Maybe Double) -- ^ "ytdChangePercent"
  , inlineResponse20026Month6ChangePercent :: !(Maybe Double) -- ^ "month6ChangePercent"
  , inlineResponse20026Month3ChangePercent :: !(Maybe Double) -- ^ "month3ChangePercent"
  , inlineResponse20026Month1ChangePercent :: !(Maybe Double) -- ^ "month1ChangePercent"
  , inlineResponse20026Day5ChangePercent :: !(Maybe Double) -- ^ "day5ChangePercent"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolStatsGetResponse
instance A.FromJSON StockSymbolStatsGetResponse where
  parseJSON = A.withObject "StockSymbolStatsGetResponse" $ \o ->
    StockSymbolStatsGetResponse
      <$> (o .:? "companyName")
      <*> (o .:? "marketcap")
      <*> (o .:? "beta")
      <*> (o .:? "week52high")
      <*> (o .:? "week52low")
      <*> (o .:? "week52change")
      <*> (o .:? "shortInterest")
      <*> (o .:? "shortDate")
      <*> (o .:? "dividendRate")
      <*> (o .:? "dividendYield")
      <*> (o .:? "exDividendDate")
      <*> (o .:? "latestEPS")
      <*> (o .:? "latestEPSDate")
      <*> (o .:? "sharesOutstanding")
      <*> (o .:? "float")
      <*> (o .:? "returnOnEquity")
      <*> (o .:? "consensusEPS")
      <*> (o .:? "numberOfEstimates")
      <*> (o .:? "symbol")
      <*> (o .:? "EBITDA")
      <*> (o .:? "revenue")
      <*> (o .:? "grossProfit")
      <*> (o .:? "cash")
      <*> (o .:? "debt")
      <*> (o .:? "ttmEPS")
      <*> (o .:? "revenuePerShare")
      <*> (o .:? "revenuePerEmployee")
      <*> (o .:? "peRatioHigh")
      <*> (o .:? "peRatioLow")
      <*> (o .:? "EPSSurpriseDollar")
      <*> (o .:? "EPSSurprisePercent")
      <*> (o .:? "returnOnAssets")
      <*> (o .:? "returnOnCapital")
      <*> (o .:? "profitMargin")
      <*> (o .:? "priceToSales")
      <*> (o .:? "priceToBook")
      <*> (o .:? "day200MovingAvg")
      <*> (o .:? "day50MovingAvg")
      <*> (o .:? "institutionPercent")
      <*> (o .:? "insiderPercent")
      <*> (o .:? "shortRatio")
      <*> (o .:? "year5ChangePercent")
      <*> (o .:? "year2ChangePercent")
      <*> (o .:? "year1ChangePercent")
      <*> (o .:? "ytdChangePercent")
      <*> (o .:? "month6ChangePercent")
      <*> (o .:? "month3ChangePercent")
      <*> (o .:? "month1ChangePercent")
      <*> (o .:? "day5ChangePercent")

-- | ToJSON StockSymbolStatsGetResponse
instance A.ToJSON StockSymbolStatsGetResponse where
  toJSON StockSymbolStatsGetResponse {..} = _omitNulls
    [ "companyName" .= stockSymbolStatsGetResponseCompanyName
    , "marketcap" .= stockSymbolStatsGetResponseMarketcap
    , "beta" .= stockSymbolStatsGetResponseBeta
    , "week52high" .= inlineResponse20026Week52high
    , "week52low" .= inlineResponse20026Week52low
    , "week52change" .= inlineResponse20026Week52change
    , "shortInterest" .= stockSymbolStatsGetResponseShortInterest
    , "shortDate" .= stockSymbolStatsGetResponseShortDate
    , "dividendRate" .= stockSymbolStatsGetResponseDividendRate
    , "dividendYield" .= stockSymbolStatsGetResponseDividendYield
    , "exDividendDate" .= stockSymbolStatsGetResponseExDividendDate
    , "latestEPS" .= stockSymbolStatsGetResponseLatestEps
    , "latestEPSDate" .= stockSymbolStatsGetResponseLatestEpsDate
    , "sharesOutstanding" .= stockSymbolStatsGetResponseSharesOutstanding
    , "float" .= stockSymbolStatsGetResponseFloat
    , "returnOnEquity" .= stockSymbolStatsGetResponseReturnOnEquity
    , "consensusEPS" .= stockSymbolStatsGetResponseConsensusEps
    , "numberOfEstimates" .= stockSymbolStatsGetResponseNumberOfEstimates
    , "symbol" .= stockSymbolStatsGetResponseSymbol
    , "EBITDA" .= stockSymbolStatsGetResponseEbitda
    , "revenue" .= stockSymbolStatsGetResponseRevenue
    , "grossProfit" .= stockSymbolStatsGetResponseGrossProfit
    , "cash" .= stockSymbolStatsGetResponseCash
    , "debt" .= stockSymbolStatsGetResponseDebt
    , "ttmEPS" .= stockSymbolStatsGetResponseTtmEps
    , "revenuePerShare" .= stockSymbolStatsGetResponseRevenuePerShare
    , "revenuePerEmployee" .= stockSymbolStatsGetResponseRevenuePerEmployee
    , "peRatioHigh" .= stockSymbolStatsGetResponsePeRatioHigh
    , "peRatioLow" .= stockSymbolStatsGetResponsePeRatioLow
    , "EPSSurpriseDollar" .= stockSymbolStatsGetResponseEpsSurpriseDollar
    , "EPSSurprisePercent" .= stockSymbolStatsGetResponseEpsSurprisePercent
    , "returnOnAssets" .= stockSymbolStatsGetResponseReturnOnAssets
    , "returnOnCapital" .= stockSymbolStatsGetResponseReturnOnCapital
    , "profitMargin" .= stockSymbolStatsGetResponseProfitMargin
    , "priceToSales" .= stockSymbolStatsGetResponsePriceToSales
    , "priceToBook" .= stockSymbolStatsGetResponsePriceToBook
    , "day200MovingAvg" .= inlineResponse20026Day200MovingAvg
    , "day50MovingAvg" .= inlineResponse20026Day50MovingAvg
    , "institutionPercent" .= stockSymbolStatsGetResponseInstitutionPercent
    , "insiderPercent" .= stockSymbolStatsGetResponseInsiderPercent
    , "shortRatio" .= stockSymbolStatsGetResponseShortRatio
    , "year5ChangePercent" .= inlineResponse20026Year5ChangePercent
    , "year2ChangePercent" .= inlineResponse20026Year2ChangePercent
    , "year1ChangePercent" .= inlineResponse20026Year1ChangePercent
    , "ytdChangePercent" .= stockSymbolStatsGetResponseYtdChangePercent
    , "month6ChangePercent" .= inlineResponse20026Month6ChangePercent
    , "month3ChangePercent" .= inlineResponse20026Month3ChangePercent
    , "month1ChangePercent" .= inlineResponse20026Month1ChangePercent
    , "day5ChangePercent" .= inlineResponse20026Day5ChangePercent
    ]


-- | Construct a value of type 'StockSymbolStatsGetResponse' (by applying it's required fields, if any)
mkStockSymbolStatsGetResponse :: StockSymbolStatsGetResponse
mkStockSymbolStatsGetResponse = StockSymbolStatsGetResponse
  { stockSymbolStatsGetResponseCompanyName        = Nothing
  , stockSymbolStatsGetResponseMarketcap          = Nothing
  , stockSymbolStatsGetResponseBeta               = Nothing
  , inlineResponse20026Week52high                 = Nothing
  , inlineResponse20026Week52low                  = Nothing
  , inlineResponse20026Week52change               = Nothing
  , stockSymbolStatsGetResponseShortInterest      = Nothing
  , stockSymbolStatsGetResponseShortDate          = Nothing
  , stockSymbolStatsGetResponseDividendRate       = Nothing
  , stockSymbolStatsGetResponseDividendYield      = Nothing
  , stockSymbolStatsGetResponseExDividendDate     = Nothing
  , stockSymbolStatsGetResponseLatestEps          = Nothing
  , stockSymbolStatsGetResponseLatestEpsDate      = Nothing
  , stockSymbolStatsGetResponseSharesOutstanding  = Nothing
  , stockSymbolStatsGetResponseFloat              = Nothing
  , stockSymbolStatsGetResponseReturnOnEquity     = Nothing
  , stockSymbolStatsGetResponseConsensusEps       = Nothing
  , stockSymbolStatsGetResponseNumberOfEstimates  = Nothing
  , stockSymbolStatsGetResponseSymbol             = Nothing
  , stockSymbolStatsGetResponseEbitda             = Nothing
  , stockSymbolStatsGetResponseRevenue            = Nothing
  , stockSymbolStatsGetResponseGrossProfit        = Nothing
  , stockSymbolStatsGetResponseCash               = Nothing
  , stockSymbolStatsGetResponseDebt               = Nothing
  , stockSymbolStatsGetResponseTtmEps             = Nothing
  , stockSymbolStatsGetResponseRevenuePerShare    = Nothing
  , stockSymbolStatsGetResponseRevenuePerEmployee = Nothing
  , stockSymbolStatsGetResponsePeRatioHigh        = Nothing
  , stockSymbolStatsGetResponsePeRatioLow         = Nothing
  , stockSymbolStatsGetResponseEpsSurpriseDollar  = Nothing
  , stockSymbolStatsGetResponseEpsSurprisePercent = Nothing
  , stockSymbolStatsGetResponseReturnOnAssets     = Nothing
  , stockSymbolStatsGetResponseReturnOnCapital    = Nothing
  , stockSymbolStatsGetResponseProfitMargin       = Nothing
  , stockSymbolStatsGetResponsePriceToSales       = Nothing
  , stockSymbolStatsGetResponsePriceToBook        = Nothing
  , inlineResponse20026Day200MovingAvg            = Nothing
  , inlineResponse20026Day50MovingAvg             = Nothing
  , stockSymbolStatsGetResponseInstitutionPercent = Nothing
  , stockSymbolStatsGetResponseInsiderPercent     = Nothing
  , stockSymbolStatsGetResponseShortRatio         = Nothing
  , inlineResponse20026Year5ChangePercent         = Nothing
  , inlineResponse20026Year2ChangePercent         = Nothing
  , inlineResponse20026Year1ChangePercent         = Nothing
  , stockSymbolStatsGetResponseYtdChangePercent   = Nothing
  , inlineResponse20026Month6ChangePercent        = Nothing
  , inlineResponse20026Month3ChangePercent        = Nothing
  , inlineResponse20026Month1ChangePercent        = Nothing
  , inlineResponse20026Day5ChangePercent          = Nothing
  }

-- ** StockSymbolLargestTradesGetResponse
-- | StockSymbolLargestTradesGetResponse
data StockSymbolLargestTradesGetResponse = StockSymbolLargestTradesGetResponse
  { stockSymbolLargestTradesGetResponsePrice :: !(Maybe Double) -- ^ "price" - Refers to the price of the trade
  , stockSymbolLargestTradesGetResponseSize :: !(Maybe Double) -- ^ "size" - Refers to the number of shares of the trade
  , stockSymbolLargestTradesGetResponseTime :: !(Maybe Double) -- ^ "time" - Refers to the time of the trade
  , stockSymbolLargestTradesGetResponseTimeLabel :: !(Maybe Text) -- ^ "timeLabel" - formatted time string as HH:MM:SS
  , stockSymbolLargestTradesGetResponseVenue :: !(Maybe Text) -- ^ "venue" - Refers to the venue where the trade occured. &#x60;None&#x60; refers to a. TRF (off-exchange) trade
  , stockSymbolLargestTradesGetResponseVenueName :: !(Maybe Text) -- ^ "venueName" - formatted venue name where the trade occured
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolLargestTradesGetResponse
instance A.FromJSON StockSymbolLargestTradesGetResponse where
  parseJSON = A.withObject "StockSymbolLargestTradesGetResponse" $ \o ->
    StockSymbolLargestTradesGetResponse
      <$> (o .:? "price")
      <*> (o .:? "size")
      <*> (o .:? "time")
      <*> (o .:? "timeLabel")
      <*> (o .:? "venue")
      <*> (o .:? "venueName")

-- | ToJSON StockSymbolLargestTradesGetResponse
instance A.ToJSON StockSymbolLargestTradesGetResponse where
  toJSON StockSymbolLargestTradesGetResponse {..} = _omitNulls
    [ "price" .= stockSymbolLargestTradesGetResponsePrice
    , "size" .= stockSymbolLargestTradesGetResponseSize
    , "time" .= stockSymbolLargestTradesGetResponseTime
    , "timeLabel" .= stockSymbolLargestTradesGetResponseTimeLabel
    , "venue" .= stockSymbolLargestTradesGetResponseVenue
    , "venueName" .= stockSymbolLargestTradesGetResponseVenueName
    ]


-- | Construct a value of type 'StockSymbolLargestTradesGetResponse' (by applying it's required fields, if any)
mkStockSymbolLargestTradesGetResponse :: StockSymbolLargestTradesGetResponse
mkStockSymbolLargestTradesGetResponse = StockSymbolLargestTradesGetResponse
  { stockSymbolLargestTradesGetResponsePrice     = Nothing
  , stockSymbolLargestTradesGetResponseSize      = Nothing
  , stockSymbolLargestTradesGetResponseTime      = Nothing
  , stockSymbolLargestTradesGetResponseTimeLabel = Nothing
  , stockSymbolLargestTradesGetResponseVenue     = Nothing
  , stockSymbolLargestTradesGetResponseVenueName = Nothing
  }

-- ** StockSymbolLogoGetResponse
-- | StockSymbolLogoGetResponse
data StockSymbolLogoGetResponse = StockSymbolLogoGetResponse
  { stockSymbolLogoGetResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolLogoGetResponse
instance A.FromJSON StockSymbolLogoGetResponse where
  parseJSON = A.withObject "StockSymbolLogoGetResponse"
    $ \o -> StockSymbolLogoGetResponse <$> (o .:? "url")

-- | ToJSON StockSymbolLogoGetResponse
instance A.ToJSON StockSymbolLogoGetResponse where
  toJSON StockSymbolLogoGetResponse {..} =
    _omitNulls ["url" .= stockSymbolLogoGetResponseUrl]


-- | Construct a value of type 'StockSymbolLogoGetResponse' (by applying it's required fields, if any)
mkStockSymbolLogoGetResponse :: StockSymbolLogoGetResponse
mkStockSymbolLogoGetResponse =
  StockSymbolLogoGetResponse { stockSymbolLogoGetResponseUrl = Nothing }

-- ** StockSymbolRelevantGetResponse
-- | StockSymbolRelevantGetResponse
data StockSymbolRelevantGetResponse = StockSymbolRelevantGetResponse
  { stockSymbolRelevantGetResponsePeers :: !(Maybe Bool) -- ^ "peers"
  , stockSymbolRelevantGetResponseSymbols :: !(Maybe [Text]) -- ^ "symbols"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolRelevantGetResponse
instance A.FromJSON StockSymbolRelevantGetResponse where
  parseJSON = A.withObject "StockSymbolRelevantGetResponse" $ \o ->
    StockSymbolRelevantGetResponse <$> (o .:? "peers") <*> (o .:? "symbols")

-- | ToJSON StockSymbolRelevantGetResponse
instance A.ToJSON StockSymbolRelevantGetResponse where
  toJSON StockSymbolRelevantGetResponse {..} = _omitNulls
    [ "peers" .= stockSymbolRelevantGetResponsePeers
    , "symbols" .= stockSymbolRelevantGetResponseSymbols
    ]


-- | Construct a value of type 'StockSymbolRelevantGetResponse' (by applying it's required fields, if any)
mkStockSymbolRelevantGetResponse :: StockSymbolRelevantGetResponse
mkStockSymbolRelevantGetResponse = StockSymbolRelevantGetResponse
  { stockSymbolRelevantGetResponsePeers   = Nothing
  , stockSymbolRelevantGetResponseSymbols = Nothing
  }

-- ** TopsLastGetResponse
-- | TopsLastGetResponse
data TopsLastGetResponse = TopsLastGetResponse
  { topsLastGetResponseSymbol :: !(Maybe Text) -- ^ "symbol" - Refers to the stock ticker
  , topsLastGetResponsePrice :: !(Maybe Double) -- ^ "price" - Refers to last sale price of the stock on IEX. Refer to the attribution section.
  , topsLastGetResponseSize :: !(Maybe Double) -- ^ "size" - Refers to the last sale size of the stock on IEX.
  , topsLastGetResponseTime :: !(Maybe Double) -- ^ "time" - Refers to last sale time in epoch time of the stock on IEX.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopsLastGetResponse
instance A.FromJSON TopsLastGetResponse where
  parseJSON = A.withObject "TopsLastGetResponse" $ \o ->
    TopsLastGetResponse
      <$> (o .:? "symbol")
      <*> (o .:? "price")
      <*> (o .:? "size")
      <*> (o .:? "time")

-- | ToJSON TopsLastGetResponse
instance A.ToJSON TopsLastGetResponse where
  toJSON TopsLastGetResponse {..} = _omitNulls
    [ "symbol" .= topsLastGetResponseSymbol
    , "price" .= topsLastGetResponsePrice
    , "size" .= topsLastGetResponseSize
    , "time" .= topsLastGetResponseTime
    ]


-- | Construct a value of type 'TopsLastGetResponse' (by applying it's required fields, if any)
mkTopsLastGetResponse :: TopsLastGetResponse
mkTopsLastGetResponse = TopsLastGetResponse
  { topsLastGetResponseSymbol = Nothing
  , topsLastGetResponsePrice  = Nothing
  , topsLastGetResponseSize   = Nothing
  , topsLastGetResponseTime   = Nothing
  }

-- ** StockMarketSectorPerformanceGetResponse
-- | StockMarketSectorPerformanceGetResponse
data StockMarketSectorPerformanceGetResponse = StockMarketSectorPerformanceGetResponse
  { stockMarketSectorPerformanceGetResponseType :: !(Maybe Text) -- ^ "type" - The type of performance data return. Should always be &#x60;sector&#x60;.
  , stockMarketSectorPerformanceGetResponseName :: !(Maybe Sector) -- ^ "name"
  , stockMarketSectorPerformanceGetResponsePerformance :: !(Maybe Double) -- ^ "performance" - Change percent of the sector for the trading day.
  , stockMarketSectorPerformanceGetResponseLastUpdated :: !(Maybe Double) -- ^ "lastUpdated" - Last updated time of the performance metric represented as millisecond epoch.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockMarketSectorPerformanceGetResponse
instance A.FromJSON StockMarketSectorPerformanceGetResponse where
  parseJSON = A.withObject "StockMarketSectorPerformanceGetResponse" $ \o ->
    StockMarketSectorPerformanceGetResponse
      <$> (o .:? "type")
      <*> (o .:? "name")
      <*> (o .:? "performance")
      <*> (o .:? "lastUpdated")

-- | ToJSON StockMarketSectorPerformanceGetResponse
instance A.ToJSON StockMarketSectorPerformanceGetResponse where
  toJSON StockMarketSectorPerformanceGetResponse {..} = _omitNulls
    [ "type" .= stockMarketSectorPerformanceGetResponseType
    , "name" .= stockMarketSectorPerformanceGetResponseName
    , "performance" .= stockMarketSectorPerformanceGetResponsePerformance
    , "lastUpdated" .= stockMarketSectorPerformanceGetResponseLastUpdated
    ]


-- | Construct a value of type 'StockMarketSectorPerformanceGetResponse' (by applying it's required fields, if any)
mkStockMarketSectorPerformanceGetResponse
  :: StockMarketSectorPerformanceGetResponse
mkStockMarketSectorPerformanceGetResponse =
  StockMarketSectorPerformanceGetResponse
    { stockMarketSectorPerformanceGetResponseType        = Nothing
    , stockMarketSectorPerformanceGetResponseName        = Nothing
    , stockMarketSectorPerformanceGetResponsePerformance = Nothing
    , stockMarketSectorPerformanceGetResponseLastUpdated = Nothing
    }

-- ** StocksSymbolSplitsRangeGetResponse
-- | StocksSymbolSplitsRangeGetResponse
data StocksSymbolSplitsRangeGetResponse = StocksSymbolSplitsRangeGetResponse
  { stocksSymbolSplitsRangeGetResponseExDate :: !(Maybe Text) -- ^ "exDate" - Refers to the split ex-Date
  , stocksSymbolSplitsRangeGetResponseDeclaredDate :: !(Maybe Text) -- ^ "declaredDate" - Refers to the split declaration date
  , stocksSymbolSplitsRangeGetResponseRecordDate :: !(Maybe Text) -- ^ "recordDate" - Refers to the split record date
  , stocksSymbolSplitsRangeGetResponsePaymentDate :: !(Maybe Text) -- ^ "paymentDate" - Refers to the split payment date
  , stocksSymbolSplitsRangeGetResponseRatio :: !(Maybe Double) -- ^ "ratio" - Refers to the split ration. The split ration is an inverse of the number  of shares that a holder of the stock would have after the split divided  by the number of shares that the holder had before. 
  , stocksSymbolSplitsRangeGetResponseToFactor :: !(Maybe Text) -- ^ "toFactor" - To factor of the split. Used to calculate the split &#x60;ratio&#x60; forfactor/tofactor &#x3D; &#x60;ratio&#x60; (e.g. 1/2 &#x3D; 0.5)
  , stocksSymbolSplitsRangeGetResponseForFactor :: !(Maybe Text) -- ^ "forFactor" - For factor of the split. Used to calculate the split &#x60;ratio&#x60; forfactor/tofactor &#x3D; &#x60;ratio&#x60; (e.g. 1/2 &#x3D; 0.5)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StocksSymbolSplitsRangeGetResponse
instance A.FromJSON StocksSymbolSplitsRangeGetResponse where
  parseJSON = A.withObject "StocksSymbolSplitsRangeGetResponse" $ \o ->
    StocksSymbolSplitsRangeGetResponse
      <$> (o .:? "exDate")
      <*> (o .:? "declaredDate")
      <*> (o .:? "recordDate")
      <*> (o .:? "paymentDate")
      <*> (o .:? "ratio")
      <*> (o .:? "toFactor")
      <*> (o .:? "forFactor")

-- | ToJSON StocksSymbolSplitsRangeGetResponse
instance A.ToJSON StocksSymbolSplitsRangeGetResponse where
  toJSON StocksSymbolSplitsRangeGetResponse {..} = _omitNulls
    [ "exDate" .= stocksSymbolSplitsRangeGetResponseExDate
    , "declaredDate" .= stocksSymbolSplitsRangeGetResponseDeclaredDate
    , "recordDate" .= stocksSymbolSplitsRangeGetResponseRecordDate
    , "paymentDate" .= stocksSymbolSplitsRangeGetResponsePaymentDate
    , "ratio" .= stocksSymbolSplitsRangeGetResponseRatio
    , "toFactor" .= stocksSymbolSplitsRangeGetResponseToFactor
    , "forFactor" .= stocksSymbolSplitsRangeGetResponseForFactor
    ]


-- | Construct a value of type 'StocksSymbolSplitsRangeGetResponse' (by applying it's required fields, if any)
mkStocksSymbolSplitsRangeGetResponse :: StocksSymbolSplitsRangeGetResponse
mkStocksSymbolSplitsRangeGetResponse = StocksSymbolSplitsRangeGetResponse
  { stocksSymbolSplitsRangeGetResponseExDate       = Nothing
  , stocksSymbolSplitsRangeGetResponseDeclaredDate = Nothing
  , stocksSymbolSplitsRangeGetResponseRecordDate   = Nothing
  , stocksSymbolSplitsRangeGetResponsePaymentDate  = Nothing
  , stocksSymbolSplitsRangeGetResponseRatio        = Nothing
  , stocksSymbolSplitsRangeGetResponseToFactor     = Nothing
  , stocksSymbolSplitsRangeGetResponseForFactor    = Nothing
  }

-- ** StockMarketTodayEarningsGetResponse
-- | StockMarketTodayEarningsGetResponse
data StockMarketTodayEarningsGetResponse = StockMarketTodayEarningsGetResponse
  { stockMarketTodayEarningsGetResponseBto :: !(Maybe [TodayEarnings]) -- ^ "bto"
  , stockMarketTodayEarningsGetResponseAmc :: !(Maybe [TodayEarnings]) -- ^ "amc"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockMarketTodayEarningsGetResponse
instance A.FromJSON StockMarketTodayEarningsGetResponse where
  parseJSON = A.withObject "StockMarketTodayEarningsGetResponse" $ \o ->
    StockMarketTodayEarningsGetResponse <$> (o .:? "bto") <*> (o .:? "amc")

-- | ToJSON StockMarketTodayEarningsGetResponse
instance A.ToJSON StockMarketTodayEarningsGetResponse where
  toJSON StockMarketTodayEarningsGetResponse {..} = _omitNulls
    [ "bto" .= stockMarketTodayEarningsGetResponseBto
    , "amc" .= stockMarketTodayEarningsGetResponseAmc
    ]


-- | Construct a value of type 'StockMarketTodayEarningsGetResponse' (by applying it's required fields, if any)
mkStockMarketTodayEarningsGetResponse :: StockMarketTodayEarningsGetResponse
mkStockMarketTodayEarningsGetResponse = StockMarketTodayEarningsGetResponse
  { stockMarketTodayEarningsGetResponseBto = Nothing
  , stockMarketTodayEarningsGetResponseAmc = Nothing
  }

-- ** StockSymbolVolumeByVenueGetResponse
-- | StockSymbolVolumeByVenueGetResponse
data StockSymbolVolumeByVenueGetResponse = StockSymbolVolumeByVenueGetResponse
  { stockSymbolVolumeByVenueGetResponseVolume :: !(Maybe Double) -- ^ "volume" - Refers to the current day, 15 minute delayed volume 
  , stockSymbolVolumeByVenueGetResponseVenue :: !(Maybe Text) -- ^ "venue" - Refeers to the Market Identifier Code (MIC)
  , stockSymbolVolumeByVenueGetResponseVenueName :: !(Maybe Text) -- ^ "venueName" - Refers to a readable version of the venue defined by IEX
  , stockSymbolVolumeByVenueGetResponseDate :: !(Maybe Date) -- ^ "date" - Refers to the date the data was last updated in the format &#x60;YYYY-MM-DD&#x60;
  , stockSymbolVolumeByVenueGetResponseMarketPercent :: !(Maybe Double) -- ^ "marketPercent" - Refers tot the 15 minute delayed percent of total stock volume traded by the venue
  , stockSymbolVolumeByVenueGetResponseAvgMarketPercent :: !(Maybe Double) -- ^ "avgMarketPercent" - Refers to the 30 day average percent of total stock volume traded by the venue
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StockSymbolVolumeByVenueGetResponse
instance A.FromJSON StockSymbolVolumeByVenueGetResponse where
  parseJSON = A.withObject "StockSymbolVolumeByVenueGetResponse" $ \o ->
    StockSymbolVolumeByVenueGetResponse
      <$> (o .:? "volume")
      <*> (o .:? "venue")
      <*> (o .:? "venueName")
      <*> (o .:? "date")
      <*> (o .:? "marketPercent")
      <*> (o .:? "avgMarketPercent")

-- | ToJSON StockSymbolVolumeByVenueGetResponse
instance A.ToJSON StockSymbolVolumeByVenueGetResponse where
  toJSON StockSymbolVolumeByVenueGetResponse {..} = _omitNulls
    [ "volume" .= stockSymbolVolumeByVenueGetResponseVolume
    , "venue" .= stockSymbolVolumeByVenueGetResponseVenue
    , "venueName" .= stockSymbolVolumeByVenueGetResponseVenueName
    , "date" .= stockSymbolVolumeByVenueGetResponseDate
    , "marketPercent" .= stockSymbolVolumeByVenueGetResponseMarketPercent
    , "avgMarketPercent" .= stockSymbolVolumeByVenueGetResponseAvgMarketPercent
    ]


-- | Construct a value of type 'StockSymbolVolumeByVenueGetResponse' (by applying it's required fields, if any)
mkStockSymbolVolumeByVenueGetResponse :: StockSymbolVolumeByVenueGetResponse
mkStockSymbolVolumeByVenueGetResponse = StockSymbolVolumeByVenueGetResponse
  { stockSymbolVolumeByVenueGetResponseVolume           = Nothing
  , stockSymbolVolumeByVenueGetResponseVenue            = Nothing
  , stockSymbolVolumeByVenueGetResponseVenueName        = Nothing
  , stockSymbolVolumeByVenueGetResponseDate             = Nothing
  , stockSymbolVolumeByVenueGetResponseMarketPercent    = Nothing
  , stockSymbolVolumeByVenueGetResponseAvgMarketPercent = Nothing
  }

-- ** DeepOfficialPriceGetResponse
-- | DeepOfficialPriceGetResponse
data DeepOfficialPriceGetResponse = DeepOfficialPriceGetResponse
  { deepOfficialPriceGetResponsePriceType :: !(Maybe E'PriceType) -- ^ "priceType"
  , deepOfficialPriceGetResponsePrice :: !(Maybe Double) -- ^ "price"
  , deepOfficialPriceGetResponseTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepOfficialPriceGetResponse
instance A.FromJSON DeepOfficialPriceGetResponse where
  parseJSON = A.withObject "DeepOfficialPriceGetResponse" $ \o ->
    DeepOfficialPriceGetResponse
      <$> (o .:? "priceType")
      <*> (o .:? "price")
      <*> (o .:? "timestamp")

-- | ToJSON DeepOfficialPriceGetResponse
instance A.ToJSON DeepOfficialPriceGetResponse where
  toJSON DeepOfficialPriceGetResponse {..} = _omitNulls
    [ "priceType" .= deepOfficialPriceGetResponsePriceType
    , "price" .= deepOfficialPriceGetResponsePrice
    , "timestamp" .= deepOfficialPriceGetResponseTimestamp
    ]


-- | Construct a value of type 'DeepOfficialPriceGetResponse' (by applying it's required fields, if any)
mkDeepOfficialPriceGetResponse :: DeepOfficialPriceGetResponse
mkDeepOfficialPriceGetResponse = DeepOfficialPriceGetResponse
  { deepOfficialPriceGetResponsePriceType = Nothing
  , deepOfficialPriceGetResponsePrice     = Nothing
  , deepOfficialPriceGetResponseTimestamp = Nothing
  }

-- ** DeepOpHaltStatusGetResponse
-- | DeepOpHaltStatusGetResponse
data DeepOpHaltStatusGetResponse = DeepOpHaltStatusGetResponse
  { deepOpHaltStatusGetResponseIsHalted :: !(Maybe Bool) -- ^ "isHalted"
  , deepOpHaltStatusGetResponseTimeStamp :: !(Maybe Double) -- ^ "timeStamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepOpHaltStatusGetResponse
instance A.FromJSON DeepOpHaltStatusGetResponse where
  parseJSON = A.withObject "DeepOpHaltStatusGetResponse" $ \o ->
    DeepOpHaltStatusGetResponse <$> (o .:? "isHalted") <*> (o .:? "timeStamp")

-- | ToJSON DeepOpHaltStatusGetResponse
instance A.ToJSON DeepOpHaltStatusGetResponse where
  toJSON DeepOpHaltStatusGetResponse {..} = _omitNulls
    [ "isHalted" .= deepOpHaltStatusGetResponseIsHalted
    , "timeStamp" .= deepOpHaltStatusGetResponseTimeStamp
    ]


-- | Construct a value of type 'DeepOpHaltStatusGetResponse' (by applying it's required fields, if any)
mkDeepOpHaltStatusGetResponse :: DeepOpHaltStatusGetResponse
mkDeepOpHaltStatusGetResponse = DeepOpHaltStatusGetResponse
  { deepOpHaltStatusGetResponseIsHalted  = Nothing
  , deepOpHaltStatusGetResponseTimeStamp = Nothing
  }

-- ** DeepSecurityEventGetResponse
-- | DeepSecurityEventGetResponse
data DeepSecurityEventGetResponse = DeepSecurityEventGetResponse
  { deepSecurityEventGetResponseSecurityEvent :: !(Maybe E'SecurityEvent) -- ^ "securityEvent"
  , deepSecurityEventGetResponseTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepSecurityEventGetResponse
instance A.FromJSON DeepSecurityEventGetResponse where
  parseJSON = A.withObject "DeepSecurityEventGetResponse" $ \o ->
    DeepSecurityEventGetResponse
      <$> (o .:? "securityEvent")
      <*> (o .:? "timestamp")

-- | ToJSON DeepSecurityEventGetResponse
instance A.ToJSON DeepSecurityEventGetResponse where
  toJSON DeepSecurityEventGetResponse {..} = _omitNulls
    [ "securityEvent" .= deepSecurityEventGetResponseSecurityEvent
    , "timestamp" .= deepSecurityEventGetResponseTimestamp
    ]


-- | Construct a value of type 'DeepSecurityEventGetResponse' (by applying it's required fields, if any)
mkDeepSecurityEventGetResponse :: DeepSecurityEventGetResponse
mkDeepSecurityEventGetResponse = DeepSecurityEventGetResponse
  { deepSecurityEventGetResponseSecurityEvent = Nothing
  , deepSecurityEventGetResponseTimestamp     = Nothing
  }

-- ** DeepSystemEventGetResponse
-- | DeepSystemEventGetResponse
data DeepSystemEventGetResponse = DeepSystemEventGetResponse
  { deepSystemEventGetResponseSystemEvent :: !(Maybe SystemEvent) -- ^ "systemEvent"
  , deepSystemEventGetResponseTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepSystemEventGetResponse
instance A.FromJSON DeepSystemEventGetResponse where
  parseJSON = A.withObject "DeepSystemEventGetResponse" $ \o ->
    DeepSystemEventGetResponse <$> (o .:? "systemEvent") <*> (o .:? "timestamp")

-- | ToJSON DeepSystemEventGetResponse
instance A.ToJSON DeepSystemEventGetResponse where
  toJSON DeepSystemEventGetResponse {..} = _omitNulls
    [ "systemEvent" .= deepSystemEventGetResponseSystemEvent
    , "timestamp" .= deepSystemEventGetResponseTimestamp
    ]


-- | Construct a value of type 'DeepSystemEventGetResponse' (by applying it's required fields, if any)
mkDeepSystemEventGetResponse :: DeepSystemEventGetResponse
mkDeepSystemEventGetResponse = DeepSystemEventGetResponse
  { deepSystemEventGetResponseSystemEvent = Nothing
  , deepSystemEventGetResponseTimestamp   = Nothing
  }

-- ** TopsGetResponse
-- | TopsGetResponse
data TopsGetResponse = TopsGetResponse
  { topsGetResponseSymbol :: !(Maybe Text) -- ^ "symbol" - Refers to the stock ticker
  , topsGetResponseMarketPercent :: !(Maybe Double) -- ^ "marketPercent"
  , topsGetResponseBidSize :: !(Maybe Double) -- ^ "bidSize" - Refers to IEX&#39;s percentage of the market in the stock
  , topsGetResponseBidPrice :: !(Maybe Double) -- ^ "bidPrice" - Refers to the best bid price on IEX
  , topsGetResponseAskSize :: !(Maybe Double) -- ^ "askSize" - Refers to amount of shares on the ask on IEX
  , topsGetResponseAskPrice :: !(Maybe Double) -- ^ "askPrice" - Refers to the best ask price on IEX
  , topsGetResponseVolume :: !(Maybe Double) -- ^ "volume" - Refers to shares traded in the stock on IEX
  , topsGetResponseLastSalePrice :: !(Maybe Double) -- ^ "lastSalePrice" - Refers to last sale price of the stock on IEX. Refer to the attribution section.
  , topsGetResponseLastSaleSize :: !(Maybe Double) -- ^ "lastSaleSize" - Refers to last sale size of the stock on IEX
  , topsGetResponseLastSaleTime :: !(Maybe Double) -- ^ "lastSaleTime" - Refers to last sale time in epoch time of the stock on IEX.
  , topsGetResponseLastUpdated :: !(Maybe Double) -- ^ "lastUpdated" - Refers to the last update time of the data in milliseconds since midnight  Jan 1, 1970 or &#x60;-1&#x60;. If the value is &#x60;-1&#x60;, IEX has not quoted the symbol in the trading day. 
  , topsGetResponseSector :: !(Maybe Sector) -- ^ "sector"
  , topsGetResponseSecurityType :: !(Maybe Text) -- ^ "securityType" - Refers to the common issue type.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopsGetResponse
instance A.FromJSON TopsGetResponse where
  parseJSON = A.withObject "TopsGetResponse" $ \o ->
    TopsGetResponse
      <$> (o .:? "symbol")
      <*> (o .:? "marketPercent")
      <*> (o .:? "bidSize")
      <*> (o .:? "bidPrice")
      <*> (o .:? "askSize")
      <*> (o .:? "askPrice")
      <*> (o .:? "volume")
      <*> (o .:? "lastSalePrice")
      <*> (o .:? "lastSaleSize")
      <*> (o .:? "lastSaleTime")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "sector")
      <*> (o .:? "securityType")

-- | ToJSON TopsGetResponse
instance A.ToJSON TopsGetResponse where
  toJSON TopsGetResponse {..} = _omitNulls
    [ "symbol" .= topsGetResponseSymbol
    , "marketPercent" .= topsGetResponseMarketPercent
    , "bidSize" .= topsGetResponseBidSize
    , "bidPrice" .= topsGetResponseBidPrice
    , "askSize" .= topsGetResponseAskSize
    , "askPrice" .= topsGetResponseAskPrice
    , "volume" .= topsGetResponseVolume
    , "lastSalePrice" .= topsGetResponseLastSalePrice
    , "lastSaleSize" .= topsGetResponseLastSaleSize
    , "lastSaleTime" .= topsGetResponseLastSaleTime
    , "lastUpdated" .= topsGetResponseLastUpdated
    , "sector" .= topsGetResponseSector
    , "securityType" .= topsGetResponseSecurityType
    ]


-- | Construct a value of type 'TopsGetResponse' (by applying it's required fields, if any)
mkTopsGetResponse :: TopsGetResponse
mkTopsGetResponse = TopsGetResponse { topsGetResponseSymbol        = Nothing
                                    , topsGetResponseMarketPercent = Nothing
                                    , topsGetResponseBidSize       = Nothing
                                    , topsGetResponseBidPrice      = Nothing
                                    , topsGetResponseAskSize       = Nothing
                                    , topsGetResponseAskPrice      = Nothing
                                    , topsGetResponseVolume        = Nothing
                                    , topsGetResponseLastSalePrice = Nothing
                                    , topsGetResponseLastSaleSize  = Nothing
                                    , topsGetResponseLastSaleTime  = Nothing
                                    , topsGetResponseLastUpdated   = Nothing
                                    , topsGetResponseSector        = Nothing
                                    , topsGetResponseSecurityType  = Nothing
                                    }

-- ** DeepTradingStatusGetResponse
-- | DeepTradingStatusGetResponse
data DeepTradingStatusGetResponse = DeepTradingStatusGetResponse
  { deepTradingStatusGetResponseStatus :: !(Maybe E'Status) -- ^ "status" - * &#x60;H&#x60; Trading halted across all US equity markets * &#x60;O&#x60; Trading halt released into an ORder Acceptance Period (IEX-listed securities only) * &#x60;P&#x60; Trading paused and Order Acceptance Period on IEX (IEX-listed securities only) * &#x60;T&#x60; Trading on IEX 
  , deepTradingStatusGetResponseReason :: !(Maybe E'Reason) -- ^ "reason" - Trading Halt Reasons   * &#x60;T1&#x60; Halt News Pending   * &#x60;IPO1&#x60; IPO/New Issue Not Yet Trading   * &#x60;IPOD&#x60; IPO/New Issue Deferred   * &#x60;MCB3&#x60; Market-Wide ircuit Breaker Level 3 - Breaked   &#x60;NA&#x60; Reason Not Available Order Acceptance Period Reasons   * &#x60;T2&#x60; Halt News Dissemination   * &#x60;IPO2&#x60; IPO/New Issue Order Acceptance Period   * &#x60;IPO3&#x60; IPO Pre-Launch Period   * &#x60;MCB1&#x60; Market-Wide Circuit Breaker Level 1 - Breached   * &#x60;MCB2&#x60; Market-Wide Circuit Breaker Level 2 - Breached 
  , deepTradingStatusGetResponseTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeepTradingStatusGetResponse
instance A.FromJSON DeepTradingStatusGetResponse where
  parseJSON = A.withObject "DeepTradingStatusGetResponse" $ \o ->
    DeepTradingStatusGetResponse
      <$> (o .:? "status")
      <*> (o .:? "reason")
      <*> (o .:? "timestamp")

-- | ToJSON DeepTradingStatusGetResponse
instance A.ToJSON DeepTradingStatusGetResponse where
  toJSON DeepTradingStatusGetResponse {..} = _omitNulls
    [ "status" .= deepTradingStatusGetResponseStatus
    , "reason" .= deepTradingStatusGetResponseReason
    , "timestamp" .= deepTradingStatusGetResponseTimestamp
    ]


-- | Construct a value of type 'DeepTradingStatusGetResponse' (by applying it's required fields, if any)
mkDeepTradingStatusGetResponse :: DeepTradingStatusGetResponse
mkDeepTradingStatusGetResponse = DeepTradingStatusGetResponse
  { deepTradingStatusGetResponseStatus    = Nothing
  , deepTradingStatusGetResponseReason    = Nothing
  , deepTradingStatusGetResponseTimestamp = Nothing
  }

-- ** IpoRawData
-- | IpoRawData
data IpoRawData = IpoRawData
  { ipoRawDataSymbol :: !(Maybe Text) -- ^ "symbol" - Refers to the IPO symbol
  , ipoRawDataCompanyName :: !(Maybe Text) -- ^ "companyName" - Refers to the name of the IPO company
  , ipoRawDataExpectedDate :: !(Maybe Text) -- ^ "expectedDate" - Refers to the date the IPO is expected to start trading
  , ipoRawDataLeadUnderwriters :: !(Maybe [Text]) -- ^ "leadUnderwriters" - refers to the list of investment banks leading the IPO
  , ipoRawDataUnderwriters :: !(Maybe [Text]) -- ^ "underwriters" - refers to the list of investment banks underwriting the IPO
  , ipoRawDataCompanyCounsel :: !(Maybe [Text]) -- ^ "companyCounsel" - refers to the list of legal firms representing the company
  , ipoRawDataUnderWriterCounsel :: !(Maybe [Text]) -- ^ "underWriterCounsel" - refers to the list of legal firms representing the underwriter
  , ipoRawDataAuditor :: !(Maybe Text) -- ^ "auditor" - Refers to the auditing firm for the company
  , ipoRawDataMarket :: !(Maybe Text) -- ^ "market" - Refers to the exchange listing the IPO
  , ipoRawDataCik :: !(Maybe Text) -- ^ "cik" - Refers to the Central Index Key assigned by the SEC to identify filings
  , ipoRawDataAddress :: !(Maybe Text) -- ^ "address" - Refers to the company address
  , ipoRawDataCity :: !(Maybe Text) -- ^ "city" - Refers to the company city
  , ipoRawDataState :: !(Maybe Text) -- ^ "state" - Refers to the company state
  , ipoRawDataZip :: !(Maybe Text) -- ^ "zip" - Refers to the company zip code
  , ipoRawDataPhone :: !(Maybe Text) -- ^ "phone" - refers to the company phone number
  , ipoRawDataCeo :: !(Maybe Text) -- ^ "ceo" - refers to the name of the company CEO
  , ipoRawDataEmployees :: !(Maybe Double) -- ^ "employees" - refers to the number of employees in the company
  , ipoRawDataUrl :: !(Maybe Text) -- ^ "url" - refers to the URL of the company website
  , ipoRawDataStatus :: !(Maybe Text) -- ^ "status" - Refers to the filing status of the SEC Form S-1
  , ipoRawDataSharesOffered :: !(Maybe Double) -- ^ "sharesOffered" - Refers to the number of shares offered in the IPO
  , ipoRawDataPriceLow :: !(Maybe Double) -- ^ "priceLow" - Refers to the low end estimate of IPO share price. On the day of the IPO, this will be the syndicate price  which is used similarly to &#x60;previousClose&#x60; to determine change versus current price. 
  , ipoRawDataPriceHigh :: !(Maybe Double) -- ^ "priceHigh" - Refers to the high end estimate of IPO share price. On the day of the IPO, this value may be null. 
  , ipoRawDataOfferAmount :: !(Maybe Double) -- ^ "offerAmount" - Refers to the notional value of the IPO in dollars
  , ipoRawDataTotalExpenses :: !(Maybe Double) -- ^ "totalExpenses" - Refers to company total expenses in dollars
  , ipoRawDataSharesOverAlloted :: !(Maybe Double) -- ^ "sharesOverAlloted" - Refers to number of shares alloted by underwriters in excess of IPO offering.
  , ipoRawDataShareholderShares :: !(Maybe Double) -- ^ "shareholderShares" - Refers to number of shares offered by existing shareholders
  , ipoRawDataSharesOutstanding :: !(Maybe Double) -- ^ "sharesOutstanding" - SRefers to the total number of company shares outstanding
  , ipoRawDataLockupPeriodExpiration :: !(Maybe Text) -- ^ "lockupPeriodExpiration" - Refers to the date of insider lockup period expiration
  , ipoRawDataQuietPeriodExpiration :: !(Maybe Text) -- ^ "quietPeriodExpiration" - Refers to the date following IPO when company quiet period expires
  , ipoRawDataRevenue :: !(Maybe Double) -- ^ "revenue" - Refers to company revenue in dollars
  , ipoRawDataNetIncome :: !(Maybe Double) -- ^ "netIncome" - Refers to company net income in dollars
  , ipoRawDataTotalAssets :: !(Maybe Double) -- ^ "totalAssets" - Refers to company total assets in dolars
  , ipoRawDataTotalLiabilities :: !(Maybe Double) -- ^ "totalLiabilities" - Refers to company total liabilities in dollars
  , ipoRawDataStockholderEquity :: !(Maybe Double) -- ^ "stockholderEquity" - Refers to stock holder equity in dollars
  , ipoRawDataCompanyDescription :: !(Maybe Text) -- ^ "companyDescription" - Description of the company
  , ipoRawDataBusinessDescription :: !(Maybe Text) -- ^ "businessDescription" - description of the company&#39;s business
  , ipoRawDataUseOfProceeds :: !(Maybe Text) -- ^ "useOfProceeds" - description of the company&#39;s planned use of proceeds from the IPO
  , ipoRawDataCompetition :: !(Maybe Text) -- ^ "competition" - description of the company&#39;s competition
  , ipoRawDataAmount :: !(Maybe Double) -- ^ "amount" - Refers to the notional balue of sharees offered * average share price in dollars
  , ipoRawDataPercentOffered :: !(Maybe Double) -- ^ "percentOffered" - Refers to the percent of outstanding shares being offered as a whole number
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IpoRawData
instance A.FromJSON IpoRawData where
  parseJSON = A.withObject "IpoRawData" $ \o ->
    IpoRawData
      <$> (o .:? "symbol")
      <*> (o .:? "companyName")
      <*> (o .:? "expectedDate")
      <*> (o .:? "leadUnderwriters")
      <*> (o .:? "underwriters")
      <*> (o .:? "companyCounsel")
      <*> (o .:? "underWriterCounsel")
      <*> (o .:? "auditor")
      <*> (o .:? "market")
      <*> (o .:? "cik")
      <*> (o .:? "address")
      <*> (o .:? "city")
      <*> (o .:? "state")
      <*> (o .:? "zip")
      <*> (o .:? "phone")
      <*> (o .:? "ceo")
      <*> (o .:? "employees")
      <*> (o .:? "url")
      <*> (o .:? "status")
      <*> (o .:? "sharesOffered")
      <*> (o .:? "priceLow")
      <*> (o .:? "priceHigh")
      <*> (o .:? "offerAmount")
      <*> (o .:? "totalExpenses")
      <*> (o .:? "sharesOverAlloted")
      <*> (o .:? "shareholderShares")
      <*> (o .:? "sharesOutstanding")
      <*> (o .:? "lockupPeriodExpiration")
      <*> (o .:? "quietPeriodExpiration")
      <*> (o .:? "revenue")
      <*> (o .:? "netIncome")
      <*> (o .:? "totalAssets")
      <*> (o .:? "totalLiabilities")
      <*> (o .:? "stockholderEquity")
      <*> (o .:? "companyDescription")
      <*> (o .:? "businessDescription")
      <*> (o .:? "useOfProceeds")
      <*> (o .:? "competition")
      <*> (o .:? "amount")
      <*> (o .:? "percentOffered")

-- | ToJSON IpoRawData
instance A.ToJSON IpoRawData where
  toJSON IpoRawData {..} = _omitNulls
    [ "symbol" .= ipoRawDataSymbol
    , "companyName" .= ipoRawDataCompanyName
    , "expectedDate" .= ipoRawDataExpectedDate
    , "leadUnderwriters" .= ipoRawDataLeadUnderwriters
    , "underwriters" .= ipoRawDataUnderwriters
    , "companyCounsel" .= ipoRawDataCompanyCounsel
    , "underWriterCounsel" .= ipoRawDataUnderWriterCounsel
    , "auditor" .= ipoRawDataAuditor
    , "market" .= ipoRawDataMarket
    , "cik" .= ipoRawDataCik
    , "address" .= ipoRawDataAddress
    , "city" .= ipoRawDataCity
    , "state" .= ipoRawDataState
    , "zip" .= ipoRawDataZip
    , "phone" .= ipoRawDataPhone
    , "ceo" .= ipoRawDataCeo
    , "employees" .= ipoRawDataEmployees
    , "url" .= ipoRawDataUrl
    , "status" .= ipoRawDataStatus
    , "sharesOffered" .= ipoRawDataSharesOffered
    , "priceLow" .= ipoRawDataPriceLow
    , "priceHigh" .= ipoRawDataPriceHigh
    , "offerAmount" .= ipoRawDataOfferAmount
    , "totalExpenses" .= ipoRawDataTotalExpenses
    , "sharesOverAlloted" .= ipoRawDataSharesOverAlloted
    , "shareholderShares" .= ipoRawDataShareholderShares
    , "sharesOutstanding" .= ipoRawDataSharesOutstanding
    , "lockupPeriodExpiration" .= ipoRawDataLockupPeriodExpiration
    , "quietPeriodExpiration" .= ipoRawDataQuietPeriodExpiration
    , "revenue" .= ipoRawDataRevenue
    , "netIncome" .= ipoRawDataNetIncome
    , "totalAssets" .= ipoRawDataTotalAssets
    , "totalLiabilities" .= ipoRawDataTotalLiabilities
    , "stockholderEquity" .= ipoRawDataStockholderEquity
    , "companyDescription" .= ipoRawDataCompanyDescription
    , "businessDescription" .= ipoRawDataBusinessDescription
    , "useOfProceeds" .= ipoRawDataUseOfProceeds
    , "competition" .= ipoRawDataCompetition
    , "amount" .= ipoRawDataAmount
    , "percentOffered" .= ipoRawDataPercentOffered
    ]


-- | Construct a value of type 'IpoRawData' (by applying it's required fields, if any)
mkIpoRawData :: IpoRawData
mkIpoRawData = IpoRawData { ipoRawDataSymbol                 = Nothing
                          , ipoRawDataCompanyName            = Nothing
                          , ipoRawDataExpectedDate           = Nothing
                          , ipoRawDataLeadUnderwriters       = Nothing
                          , ipoRawDataUnderwriters           = Nothing
                          , ipoRawDataCompanyCounsel         = Nothing
                          , ipoRawDataUnderWriterCounsel     = Nothing
                          , ipoRawDataAuditor                = Nothing
                          , ipoRawDataMarket                 = Nothing
                          , ipoRawDataCik                    = Nothing
                          , ipoRawDataAddress                = Nothing
                          , ipoRawDataCity                   = Nothing
                          , ipoRawDataState                  = Nothing
                          , ipoRawDataZip                    = Nothing
                          , ipoRawDataPhone                  = Nothing
                          , ipoRawDataCeo                    = Nothing
                          , ipoRawDataEmployees              = Nothing
                          , ipoRawDataUrl                    = Nothing
                          , ipoRawDataStatus                 = Nothing
                          , ipoRawDataSharesOffered          = Nothing
                          , ipoRawDataPriceLow               = Nothing
                          , ipoRawDataPriceHigh              = Nothing
                          , ipoRawDataOfferAmount            = Nothing
                          , ipoRawDataTotalExpenses          = Nothing
                          , ipoRawDataSharesOverAlloted      = Nothing
                          , ipoRawDataShareholderShares      = Nothing
                          , ipoRawDataSharesOutstanding      = Nothing
                          , ipoRawDataLockupPeriodExpiration = Nothing
                          , ipoRawDataQuietPeriodExpiration  = Nothing
                          , ipoRawDataRevenue                = Nothing
                          , ipoRawDataNetIncome              = Nothing
                          , ipoRawDataTotalAssets            = Nothing
                          , ipoRawDataTotalLiabilities       = Nothing
                          , ipoRawDataStockholderEquity      = Nothing
                          , ipoRawDataCompanyDescription     = Nothing
                          , ipoRawDataBusinessDescription    = Nothing
                          , ipoRawDataUseOfProceeds          = Nothing
                          , ipoRawDataCompetition            = Nothing
                          , ipoRawDataAmount                 = Nothing
                          , ipoRawDataPercentOffered         = Nothing
                          }

-- ** IpoViewData
-- | IpoViewData
data IpoViewData = IpoViewData
  { ipoViewDataCompany :: !(Maybe Text) -- ^ "Company" - Refers to the name of the IPO company
  , ipoViewDataSymbol :: !(Maybe Text) -- ^ "Symbol" - Refers to the IPO symbol
  , ipoViewDataPrice :: !(Maybe Text) -- ^ "Price" - Formatted as &#x60;$priceLow - priceHigh&#x60;
  , ipoViewDataShares :: !(Maybe Text) -- ^ "Shares" - Refers to the number of shares offered in the IPO
  , ipoViewDataAmount :: !(Maybe Text) -- ^ "Amount" - Refers to the notional value of shares offered * average share price in dollars
  , ipoViewDataFloat :: !(Maybe Text) -- ^ "Float" - Refers to the total number of company shares outstanding
  , ipoViewDataPercent :: !(Maybe Text) -- ^ "Percent" - Refers to the percent of outstanding shares being offered as a whole number
  , ipoViewDataMarket :: !(Maybe Text) -- ^ "Market" - Refers to the exchange listing the IPO
  , ipoViewDataExpected :: !(Maybe Text) -- ^ "Expected" - REfers to the date the IPO is expected to start trading
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IpoViewData
instance A.FromJSON IpoViewData where
  parseJSON = A.withObject "IpoViewData" $ \o ->
    IpoViewData
      <$> (o .:? "Company")
      <*> (o .:? "Symbol")
      <*> (o .:? "Price")
      <*> (o .:? "Shares")
      <*> (o .:? "Amount")
      <*> (o .:? "Float")
      <*> (o .:? "Percent")
      <*> (o .:? "Market")
      <*> (o .:? "Expected")

-- | ToJSON IpoViewData
instance A.ToJSON IpoViewData where
  toJSON IpoViewData {..} = _omitNulls
    [ "Company" .= ipoViewDataCompany
    , "Symbol" .= ipoViewDataSymbol
    , "Price" .= ipoViewDataPrice
    , "Shares" .= ipoViewDataShares
    , "Amount" .= ipoViewDataAmount
    , "Float" .= ipoViewDataFloat
    , "Percent" .= ipoViewDataPercent
    , "Market" .= ipoViewDataMarket
    , "Expected" .= ipoViewDataExpected
    ]


-- | Construct a value of type 'IpoViewData' (by applying it's required fields, if any)
mkIpoViewData :: IpoViewData
mkIpoViewData = IpoViewData { ipoViewDataCompany  = Nothing
                            , ipoViewDataSymbol   = Nothing
                            , ipoViewDataPrice    = Nothing
                            , ipoViewDataShares   = Nothing
                            , ipoViewDataAmount   = Nothing
                            , ipoViewDataFloat    = Nothing
                            , ipoViewDataPercent  = Nothing
                            , ipoViewDataMarket   = Nothing
                            , ipoViewDataExpected = Nothing
                            }

-- ** ListedSymbolData
-- | ListedSymbolData
data ListedSymbolData = ListedSymbolData
  { listedSymbolDataRecordId :: !(Maybe Text) -- ^ "RecordID"
  , listedSymbolDataDailyListTimestamp :: !(Maybe Text) -- ^ "DailyListTimestamp"
  , listedSymbolDataSymbolinInetSymbology :: !(Maybe Text) -- ^ "SymbolinINETSymbology"
  , listedSymbolDataSymbolinCqsSymbology :: !(Maybe Text) -- ^ "SymbolinCQSSymbology"
  , listedSymbolDataSymbolinCmsSymbology :: !(Maybe Text) -- ^ "SymbolinCMSSymbology"
  , listedSymbolDataSecurityName :: !(Maybe Text) -- ^ "SecurityName"
  , listedSymbolDataCompanyName :: !(Maybe Text) -- ^ "CompanyName"
  , listedSymbolDataTestIssue :: !(Maybe Text) -- ^ "TestIssue"
  , listedSymbolDataIssueDescription :: !(Maybe Text) -- ^ "IssueDescription"
  , listedSymbolDataIssueType :: !(Maybe Text) -- ^ "IssueType"
  , listedSymbolDataIssueSubType :: !(Maybe Text) -- ^ "IssueSubType"
  , listedSymbolDataSicCode :: !(Maybe Text) -- ^ "SICCode"
  , listedSymbolDataTransferAgent :: !(Maybe Text) -- ^ "TransferAgent"
  , listedSymbolDataFinancialStatus :: !(Maybe Text) -- ^ "FinancialStatus"
  , listedSymbolDataRoundLotSize :: !(Maybe Text) -- ^ "RoundLotSize"
  , listedSymbolDataPreviousOfficialClosingPrice :: !(Maybe Text) -- ^ "PreviousOfficialClosingPrice"
  , listedSymbolDataAdjustedPreviousOfficialClosingPrice :: !(Maybe Text) -- ^ "AdjustedPreviousOfficialClosingPrice"
  , listedSymbolDataWhenIssuedFlag :: !(Maybe Text) -- ^ "WhenIssuedFlag"
  , listedSymbolDataWhenDistributedFlag :: !(Maybe Text) -- ^ "WhenDistributedFlag"
  , listedSymbolDataIpoFlag :: !(Maybe Text) -- ^ "IPOFlag"
  , listedSymbolDataFirstDateListed :: !(Maybe Text) -- ^ "FirstDateListed"
  , listedSymbolDataLuldTierIndicator :: !(Maybe Text) -- ^ "LULDTierIndicator"
  , listedSymbolDataCountryofIncorporation :: !(Maybe Text) -- ^ "CountryofIncorporation"
  , listedSymbolDataLeveragedEtpFlag :: !(Maybe Text) -- ^ "LeveragedETPFlag"
  , listedSymbolDataLeveragedEtpRatio :: !(Maybe Text) -- ^ "LeveragedETPRatio"
  , listedSymbolDataInverseEtpFlag :: !(Maybe Text) -- ^ "InverseETPFlag"
  , listedSymbolDataRecordUpdateTime :: !(Maybe Text) -- ^ "RecordUpdateTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListedSymbolData
instance A.FromJSON ListedSymbolData where
  parseJSON = A.withObject "ListedSymbolData" $ \o ->
    ListedSymbolData
      <$> (o .:? "RecordID")
      <*> (o .:? "DailyListTimestamp")
      <*> (o .:? "SymbolinINETSymbology")
      <*> (o .:? "SymbolinCQSSymbology")
      <*> (o .:? "SymbolinCMSSymbology")
      <*> (o .:? "SecurityName")
      <*> (o .:? "CompanyName")
      <*> (o .:? "TestIssue")
      <*> (o .:? "IssueDescription")
      <*> (o .:? "IssueType")
      <*> (o .:? "IssueSubType")
      <*> (o .:? "SICCode")
      <*> (o .:? "TransferAgent")
      <*> (o .:? "FinancialStatus")
      <*> (o .:? "RoundLotSize")
      <*> (o .:? "PreviousOfficialClosingPrice")
      <*> (o .:? "AdjustedPreviousOfficialClosingPrice")
      <*> (o .:? "WhenIssuedFlag")
      <*> (o .:? "WhenDistributedFlag")
      <*> (o .:? "IPOFlag")
      <*> (o .:? "FirstDateListed")
      <*> (o .:? "LULDTierIndicator")
      <*> (o .:? "CountryofIncorporation")
      <*> (o .:? "LeveragedETPFlag")
      <*> (o .:? "LeveragedETPRatio")
      <*> (o .:? "InverseETPFlag")
      <*> (o .:? "RecordUpdateTime")

-- | ToJSON ListedSymbolData
instance A.ToJSON ListedSymbolData where
  toJSON ListedSymbolData {..} = _omitNulls
    [ "RecordID" .= listedSymbolDataRecordId
    , "DailyListTimestamp" .= listedSymbolDataDailyListTimestamp
    , "SymbolinINETSymbology" .= listedSymbolDataSymbolinInetSymbology
    , "SymbolinCQSSymbology" .= listedSymbolDataSymbolinCqsSymbology
    , "SymbolinCMSSymbology" .= listedSymbolDataSymbolinCmsSymbology
    , "SecurityName" .= listedSymbolDataSecurityName
    , "CompanyName" .= listedSymbolDataCompanyName
    , "TestIssue" .= listedSymbolDataTestIssue
    , "IssueDescription" .= listedSymbolDataIssueDescription
    , "IssueType" .= listedSymbolDataIssueType
    , "IssueSubType" .= listedSymbolDataIssueSubType
    , "SICCode" .= listedSymbolDataSicCode
    , "TransferAgent" .= listedSymbolDataTransferAgent
    , "FinancialStatus" .= listedSymbolDataFinancialStatus
    , "RoundLotSize" .= listedSymbolDataRoundLotSize
    , "PreviousOfficialClosingPrice"
      .= listedSymbolDataPreviousOfficialClosingPrice
    , "AdjustedPreviousOfficialClosingPrice"
      .= listedSymbolDataAdjustedPreviousOfficialClosingPrice
    , "WhenIssuedFlag" .= listedSymbolDataWhenIssuedFlag
    , "WhenDistributedFlag" .= listedSymbolDataWhenDistributedFlag
    , "IPOFlag" .= listedSymbolDataIpoFlag
    , "FirstDateListed" .= listedSymbolDataFirstDateListed
    , "LULDTierIndicator" .= listedSymbolDataLuldTierIndicator
    , "CountryofIncorporation" .= listedSymbolDataCountryofIncorporation
    , "LeveragedETPFlag" .= listedSymbolDataLeveragedEtpFlag
    , "LeveragedETPRatio" .= listedSymbolDataLeveragedEtpRatio
    , "InverseETPFlag" .= listedSymbolDataInverseEtpFlag
    , "RecordUpdateTime" .= listedSymbolDataRecordUpdateTime
    ]


-- | Construct a value of type 'ListedSymbolData' (by applying it's required fields, if any)
mkListedSymbolData :: ListedSymbolData
mkListedSymbolData = ListedSymbolData
  { listedSymbolDataRecordId                             = Nothing
  , listedSymbolDataDailyListTimestamp                   = Nothing
  , listedSymbolDataSymbolinInetSymbology                = Nothing
  , listedSymbolDataSymbolinCqsSymbology                 = Nothing
  , listedSymbolDataSymbolinCmsSymbology                 = Nothing
  , listedSymbolDataSecurityName                         = Nothing
  , listedSymbolDataCompanyName                          = Nothing
  , listedSymbolDataTestIssue                            = Nothing
  , listedSymbolDataIssueDescription                     = Nothing
  , listedSymbolDataIssueType                            = Nothing
  , listedSymbolDataIssueSubType                         = Nothing
  , listedSymbolDataSicCode                              = Nothing
  , listedSymbolDataTransferAgent                        = Nothing
  , listedSymbolDataFinancialStatus                      = Nothing
  , listedSymbolDataRoundLotSize                         = Nothing
  , listedSymbolDataPreviousOfficialClosingPrice         = Nothing
  , listedSymbolDataAdjustedPreviousOfficialClosingPrice = Nothing
  , listedSymbolDataWhenIssuedFlag                       = Nothing
  , listedSymbolDataWhenDistributedFlag                  = Nothing
  , listedSymbolDataIpoFlag                              = Nothing
  , listedSymbolDataFirstDateListed                      = Nothing
  , listedSymbolDataLuldTierIndicator                    = Nothing
  , listedSymbolDataCountryofIncorporation               = Nothing
  , listedSymbolDataLeveragedEtpFlag                     = Nothing
  , listedSymbolDataLeveragedEtpRatio                    = Nothing
  , listedSymbolDataInverseEtpFlag                       = Nothing
  , listedSymbolDataRecordUpdateTime                     = Nothing
  }

-- ** OhlcData
-- | OhlcData
data OhlcData = OhlcData
  { ohlcDataOpen :: !(Maybe OhlcDataOpen) -- ^ "open"
  , ohlcDataClose :: !(Maybe OhlcDataClose) -- ^ "close"
  , ohlcDataHigh :: !(Maybe Double) -- ^ "high" - Refers to the market-wide highest price from the SIP (15 minute delayed)
  , ohlcDataLow :: !(Maybe Double) -- ^ "low" - Refers to the market-wide highest price from the SIP (15 minute delayed)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OhlcData
instance A.FromJSON OhlcData where
  parseJSON = A.withObject "OhlcData" $ \o ->
    OhlcData
      <$> (o .:? "open")
      <*> (o .:? "close")
      <*> (o .:? "high")
      <*> (o .:? "low")

-- | ToJSON OhlcData
instance A.ToJSON OhlcData where
  toJSON OhlcData {..} = _omitNulls
    [ "open" .= ohlcDataOpen
    , "close" .= ohlcDataClose
    , "high" .= ohlcDataHigh
    , "low" .= ohlcDataLow
    ]


-- | Construct a value of type 'OhlcData' (by applying it's required fields, if any)
mkOhlcData :: OhlcData
mkOhlcData = OhlcData { ohlcDataOpen  = Nothing
                      , ohlcDataClose = Nothing
                      , ohlcDataHigh  = Nothing
                      , ohlcDataLow   = Nothing
                      }

-- ** OhlcDataClose
-- | OhlcDataClose
data OhlcDataClose = OhlcDataClose
  { ohlcDataClosePrice :: !(Maybe Double) -- ^ "price" - Refers to the official close price
  , ohlcDataCloseTime :: !(Maybe Double) -- ^ "time" - Refers to the official listing exchange time for the close
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OhlcDataClose
instance A.FromJSON OhlcDataClose where
  parseJSON = A.withObject "OhlcDataClose"
    $ \o -> OhlcDataClose <$> (o .:? "price") <*> (o .:? "time")

-- | ToJSON OhlcDataClose
instance A.ToJSON OhlcDataClose where
  toJSON OhlcDataClose {..} =
    _omitNulls ["price" .= ohlcDataClosePrice, "time" .= ohlcDataCloseTime]


-- | Construct a value of type 'OhlcDataClose' (by applying it's required fields, if any)
mkOhlcDataClose :: OhlcDataClose
mkOhlcDataClose =
  OhlcDataClose { ohlcDataClosePrice = Nothing, ohlcDataCloseTime = Nothing }

-- ** OhlcDataOpen
-- | OhlcDataOpen
data OhlcDataOpen = OhlcDataOpen
  { ohlcDataOpenPrice :: !(Maybe Double) -- ^ "price" - Refers to the official open price
  , ohlcDataOpenTime :: !(Maybe Double) -- ^ "time" - Refers to the official listing exchange time for the open
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OhlcDataOpen
instance A.FromJSON OhlcDataOpen where
  parseJSON = A.withObject "OhlcDataOpen"
    $ \o -> OhlcDataOpen <$> (o .:? "price") <*> (o .:? "time")

-- | ToJSON OhlcDataOpen
instance A.ToJSON OhlcDataOpen where
  toJSON OhlcDataOpen {..} =
    _omitNulls ["price" .= ohlcDataOpenPrice, "time" .= ohlcDataOpenTime]


-- | Construct a value of type 'OhlcDataOpen' (by applying it's required fields, if any)
mkOhlcDataOpen :: OhlcDataOpen
mkOhlcDataOpen =
  OhlcDataOpen { ohlcDataOpenPrice = Nothing, ohlcDataOpenTime = Nothing }

-- ** Order
-- | Order
data Order = Order
  { orderPrice :: !(Maybe Double) -- ^ "price"
  , orderSize :: !(Maybe Double) -- ^ "size"
  , orderTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Order
instance A.FromJSON Order where
  parseJSON = A.withObject "Order" $ \o ->
    Order <$> (o .:? "price") <*> (o .:? "size") <*> (o .:? "timestamp")

-- | ToJSON Order
instance A.ToJSON Order where
  toJSON Order {..} = _omitNulls
    ["price" .= orderPrice, "size" .= orderSize, "timestamp" .= orderTimestamp]


-- | Construct a value of type 'Order' (by applying it's required fields, if any)
mkOrder :: Order
mkOrder =
  Order { orderPrice = Nothing, orderSize = Nothing, orderTimestamp = Nothing }

-- ** PriceData
-- | PriceData
data PriceData = PriceData
  { priceDataSymbol :: !(Maybe Text) -- ^ "symbol" - Refers to the stock ticker.
  , priceDataDate :: !(Maybe Date) -- ^ "date" - Refers to the date of the returned data in the format &#x60;YYYY-MM-DD&#x60;.
  , priceDataOpen :: !(Maybe Double) -- ^ "open"
  , priceDataHigh :: !(Maybe Double) -- ^ "high"
  , priceDataLow :: !(Maybe Double) -- ^ "low"
  , priceDataClose :: !(Maybe Double) -- ^ "close"
  , priceDataVolume :: !(Maybe Double) -- ^ "volume" - Adjusted for splits
  , priceDataUnadjustedVolume :: !(Maybe Double) -- ^ "unadjustedVolume"
  , priceDataChange :: !(Maybe Double) -- ^ "change"
  , priceDataChangePercent :: !(Maybe Double) -- ^ "changePercent"
  , priceDataVwap :: !(Maybe Double) -- ^ "vwap" - Volume weighted average price
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceData
instance A.FromJSON PriceData where
  parseJSON = A.withObject "PriceData" $ \o ->
    PriceData
      <$> (o .:? "symbol")
      <*> (o .:? "date")
      <*> (o .:? "open")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "close")
      <*> (o .:? "volume")
      <*> (o .:? "unadjustedVolume")
      <*> (o .:? "change")
      <*> (o .:? "changePercent")
      <*> (o .:? "vwap")

-- | ToJSON PriceData
instance A.ToJSON PriceData where
  toJSON PriceData {..} = _omitNulls
    [ "symbol" .= priceDataSymbol
    , "date" .= priceDataDate
    , "open" .= priceDataOpen
    , "high" .= priceDataHigh
    , "low" .= priceDataLow
    , "close" .= priceDataClose
    , "volume" .= priceDataVolume
    , "unadjustedVolume" .= priceDataUnadjustedVolume
    , "change" .= priceDataChange
    , "changePercent" .= priceDataChangePercent
    , "vwap" .= priceDataVwap
    ]


-- | Construct a value of type 'PriceData' (by applying it's required fields, if any)
mkPriceData :: PriceData
mkPriceData = PriceData { priceDataSymbol           = Nothing
                        , priceDataDate             = Nothing
                        , priceDataOpen             = Nothing
                        , priceDataHigh             = Nothing
                        , priceDataLow              = Nothing
                        , priceDataClose            = Nothing
                        , priceDataVolume           = Nothing
                        , priceDataUnadjustedVolume = Nothing
                        , priceDataChange           = Nothing
                        , priceDataChangePercent    = Nothing
                        , priceDataVwap             = Nothing
                        }

-- ** Quote
-- | Quote
data Quote = Quote
  { quoteSymbol :: !(Maybe Text) -- ^ "symbol" - Refers to the stock ticker
  , quoteCompanyName :: !(Maybe Text) -- ^ "companyName" - Refers to the company name
  , quotePrimaryExchange :: !(Maybe Text) -- ^ "primaryExchange" - Refers to the primary listings exchange
  , quoteSector :: !(Maybe Text) -- ^ "sector" - Refers to the sector of the stock
  , quoteCalculationPrice :: !(Maybe E'CalculationPrice) -- ^ "calculationPrice" - Refers to the source of the latest price
  , quoteOpen :: !(Maybe Double) -- ^ "open" - Refers to the official open price
  , quoteOpenTime :: !(Maybe Double) -- ^ "openTime" - Refers to the official listing exchange time for the open
  , quoteClose :: !(Maybe Double) -- ^ "close" - Refers to the official close price
  , quoteCloseTime :: !(Maybe Double) -- ^ "closeTime" - Refers to the official listing exchange time for the close
  , quoteHigh :: !(Maybe Double) -- ^ "high" - Refers to the market-wide highest price from the SIP.
  , quoteLow :: !(Maybe Double) -- ^ "low" - Refers to the market-wide lowest price from the SIP.
  , quoteLatestPrice :: !(Maybe Double) -- ^ "latestPrice" - Refers to the latest price being the IEX real time price,  the 15 minute delayed market price, or the previous close price 
  , quoteLatestSource :: !(Maybe E'LatestSource) -- ^ "latestSource" - Refers to the source of &#x60;latestPrice&#x60;.
  , quoteLatestTime :: !(Maybe Text) -- ^ "latestTime" - Refers to a human readable time of the &#x60;latestPrice&#x60;. The format will vary based on &#x60;latestSource&#x60;.
  , quoteLatestUpdate :: !(Maybe Double) -- ^ "latestUpdate" - Refers to the update time of &#x60;latestPrice&#x60; in milliseconds since midnight Jan 1, 1970. 
  , quoteLatestVolume :: !(Maybe Double) -- ^ "latestVolume" - Refers to the total market volume of the stock.
  , quoteIexRealtimePrice :: !(Maybe Double) -- ^ "iexRealtimePrice" - Refers to last sale price of the stock on IEX. (Refer to the attribution section.)
  , quoteIexRealtimeSize :: !(Maybe Double) -- ^ "iexRealtimeSize" - Refers to the last sale size of the stock on IEX.
  , quoteIexLastUpdated :: !(Maybe Double) -- ^ "iexLastUpdated" - Refers to the last update time of the data in milliseconds since midnight  Jan 1, 1950 UTC or &#x60;-1&#x60; or &#x60;0&#x60;. If the value is &#x60;-1&#39; or &#x60;0&#x60;,  IEX has not quoted the symbol in the trading day. 
  , quoteDelayedPrice :: !(Maybe Double) -- ^ "delayedPrice" - Refers to the 15 minute delayed market price during normal market hours 9:30 - 16:00.
  , quoteDelayedPriceTime :: !(Maybe Double) -- ^ "delayedPriceTime" - Refers to the time of the delayed market price during normal market hours 9:30 -16:00.
  , quoteExtendedPrice :: !(Maybe Double) -- ^ "extendedPrice" - Refers to the 15 minuted delayed market price outside normal market hours 8:00 - 9:30 and 16:00 - 17:00.
  , quoteExtendedChange :: !(Maybe Double) -- ^ "extendedChange" - Is calculated using &#x60;extendedPrice&#x60; from &#x60;calculationPrice&#x60;.
  , quoteExtendedChangePercent :: !(Maybe Double) -- ^ "extendedChangePercent" - Is calculated using &#x60;extendedPrice&#x60; from &#x60;calculationPrice&#x60;.
  , quoteExtendedPriceTime :: !(Maybe Double) -- ^ "extendedPriceTime" - Refers to the time of the delayed market price outside normal market hours 8:00 - 9:30 and 16:00 - 17:00.
  , quotePreviousClose :: !(Maybe Double) -- ^ "previousClose"
  , quoteChange :: !(Maybe Double) -- ^ "change" - Is calculated using &#x60;calculationPrice&#x60; from &#x60;previousClose&#x60;.
  , quoteChangePercent :: !(Maybe Double) -- ^ "changePercent" - Is calculated using &#x60;calculationPrice&#x60; from &#x60;previousClose&#x60;.
  , quoteIexMarketPercent :: !(Maybe Double) -- ^ "iexMarketPercent" - refers to IEX&#39;s percentage of the market in the stock.
  , quoteIexVolume :: !(Maybe Double) -- ^ "iexVolume" - refers to shares traded in the stock on IEX.
  , quoteAvgTotalVolume :: !(Maybe Double) -- ^ "avgTotalVolume" - Refers to the 30 day average volume on all markets.
  , quoteIexBidPrice :: !(Maybe Double) -- ^ "iexBidPrice" - Refers to the best bid price on IEX.
  , quoteIexBidSize :: !(Maybe Double) -- ^ "iexBidSize" - Refers to the amount of shares on the bid on IEX.
  , quoteIexAskPrice :: !(Maybe Double) -- ^ "iexAskPrice" - Refers to the best ask price on IEX.
  , quoteIexAskSize :: !(Maybe Double) -- ^ "iexAskSize" - Refers to the amount of shares on the ask on IEX.
  , quoteMarketCap :: !(Maybe Double) -- ^ "marketCap" - Is calculated in real time using &#x60;calculationPrice&#x60;.
  , quotePeRatio :: !(Maybe Double) -- ^ "peRatio" - Is calculated in real time using &#x60;calculationPrice&#x60;.
  , quoteWeek52High :: !(Maybe Double) -- ^ "week52High" - Refers to the adjusted 52 week high.
  , quoteWeek52Low :: !(Maybe Double) -- ^ "week52Low" - Refers to the adjusted 52 week low.
  , quoteYtdChange :: !(Maybe Double) -- ^ "ytdChange" - Refers to the price change percentage from start of year to previous close.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Quote
instance A.FromJSON Quote where
  parseJSON = A.withObject "Quote" $ \o ->
    Quote
      <$> (o .:? "symbol")
      <*> (o .:? "companyName")
      <*> (o .:? "primaryExchange")
      <*> (o .:? "sector")
      <*> (o .:? "calculationPrice")
      <*> (o .:? "open")
      <*> (o .:? "openTime")
      <*> (o .:? "close")
      <*> (o .:? "closeTime")
      <*> (o .:? "high")
      <*> (o .:? "low")
      <*> (o .:? "latestPrice")
      <*> (o .:? "latestSource")
      <*> (o .:? "latestTime")
      <*> (o .:? "latestUpdate")
      <*> (o .:? "latestVolume")
      <*> (o .:? "iexRealtimePrice")
      <*> (o .:? "iexRealtimeSize")
      <*> (o .:? "iexLastUpdated")
      <*> (o .:? "delayedPrice")
      <*> (o .:? "delayedPriceTime")
      <*> (o .:? "extendedPrice")
      <*> (o .:? "extendedChange")
      <*> (o .:? "extendedChangePercent")
      <*> (o .:? "extendedPriceTime")
      <*> (o .:? "previousClose")
      <*> (o .:? "change")
      <*> (o .:? "changePercent")
      <*> (o .:? "iexMarketPercent")
      <*> (o .:? "iexVolume")
      <*> (o .:? "avgTotalVolume")
      <*> (o .:? "iexBidPrice")
      <*> (o .:? "iexBidSize")
      <*> (o .:? "iexAskPrice")
      <*> (o .:? "iexAskSize")
      <*> (o .:? "marketCap")
      <*> (o .:? "peRatio")
      <*> (o .:? "week52High")
      <*> (o .:? "week52Low")
      <*> (o .:? "ytdChange")

-- | ToJSON Quote
instance A.ToJSON Quote where
  toJSON Quote {..} = _omitNulls
    [ "symbol" .= quoteSymbol
    , "companyName" .= quoteCompanyName
    , "primaryExchange" .= quotePrimaryExchange
    , "sector" .= quoteSector
    , "calculationPrice" .= quoteCalculationPrice
    , "open" .= quoteOpen
    , "openTime" .= quoteOpenTime
    , "close" .= quoteClose
    , "closeTime" .= quoteCloseTime
    , "high" .= quoteHigh
    , "low" .= quoteLow
    , "latestPrice" .= quoteLatestPrice
    , "latestSource" .= quoteLatestSource
    , "latestTime" .= quoteLatestTime
    , "latestUpdate" .= quoteLatestUpdate
    , "latestVolume" .= quoteLatestVolume
    , "iexRealtimePrice" .= quoteIexRealtimePrice
    , "iexRealtimeSize" .= quoteIexRealtimeSize
    , "iexLastUpdated" .= quoteIexLastUpdated
    , "delayedPrice" .= quoteDelayedPrice
    , "delayedPriceTime" .= quoteDelayedPriceTime
    , "extendedPrice" .= quoteExtendedPrice
    , "extendedChange" .= quoteExtendedChange
    , "extendedChangePercent" .= quoteExtendedChangePercent
    , "extendedPriceTime" .= quoteExtendedPriceTime
    , "previousClose" .= quotePreviousClose
    , "change" .= quoteChange
    , "changePercent" .= quoteChangePercent
    , "iexMarketPercent" .= quoteIexMarketPercent
    , "iexVolume" .= quoteIexVolume
    , "avgTotalVolume" .= quoteAvgTotalVolume
    , "iexBidPrice" .= quoteIexBidPrice
    , "iexBidSize" .= quoteIexBidSize
    , "iexAskPrice" .= quoteIexAskPrice
    , "iexAskSize" .= quoteIexAskSize
    , "marketCap" .= quoteMarketCap
    , "peRatio" .= quotePeRatio
    , "week52High" .= quoteWeek52High
    , "week52Low" .= quoteWeek52Low
    , "ytdChange" .= quoteYtdChange
    ]


-- | Construct a value of type 'Quote' (by applying it's required fields, if any)
mkQuote :: Quote
mkQuote = Quote { quoteSymbol                = Nothing
                , quoteCompanyName           = Nothing
                , quotePrimaryExchange       = Nothing
                , quoteSector                = Nothing
                , quoteCalculationPrice      = Nothing
                , quoteOpen                  = Nothing
                , quoteOpenTime              = Nothing
                , quoteClose                 = Nothing
                , quoteCloseTime             = Nothing
                , quoteHigh                  = Nothing
                , quoteLow                   = Nothing
                , quoteLatestPrice           = Nothing
                , quoteLatestSource          = Nothing
                , quoteLatestTime            = Nothing
                , quoteLatestUpdate          = Nothing
                , quoteLatestVolume          = Nothing
                , quoteIexRealtimePrice      = Nothing
                , quoteIexRealtimeSize       = Nothing
                , quoteIexLastUpdated        = Nothing
                , quoteDelayedPrice          = Nothing
                , quoteDelayedPriceTime      = Nothing
                , quoteExtendedPrice         = Nothing
                , quoteExtendedChange        = Nothing
                , quoteExtendedChangePercent = Nothing
                , quoteExtendedPriceTime     = Nothing
                , quotePreviousClose         = Nothing
                , quoteChange                = Nothing
                , quoteChangePercent         = Nothing
                , quoteIexMarketPercent      = Nothing
                , quoteIexVolume             = Nothing
                , quoteAvgTotalVolume        = Nothing
                , quoteIexBidPrice           = Nothing
                , quoteIexBidSize            = Nothing
                , quoteIexAskPrice           = Nothing
                , quoteIexAskSize            = Nothing
                , quoteMarketCap             = Nothing
                , quotePeRatio               = Nothing
                , quoteWeek52High            = Nothing
                , quoteWeek52Low             = Nothing
                , quoteYtdChange             = Nothing
                }

-- ** RecordedValue
-- | RecordedValue
data RecordedValue = RecordedValue
  { recordedValueRecordValue :: !(Maybe Double) -- ^ "recordValue"
  , recordedValueRecordDate :: !(Maybe Text) -- ^ "recordDate"
  , recordedValuePreviousDayValue :: !(Maybe Double) -- ^ "previousDayValue"
  , recordedValueAvg30Value :: !(Maybe Double) -- ^ "avg30Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecordedValue
instance A.FromJSON RecordedValue where
  parseJSON = A.withObject "RecordedValue" $ \o ->
    RecordedValue
      <$> (o .:? "recordValue")
      <*> (o .:? "recordDate")
      <*> (o .:? "previousDayValue")
      <*> (o .:? "avg30Value")

-- | ToJSON RecordedValue
instance A.ToJSON RecordedValue where
  toJSON RecordedValue {..} = _omitNulls
    [ "recordValue" .= recordedValueRecordValue
    , "recordDate" .= recordedValueRecordDate
    , "previousDayValue" .= recordedValuePreviousDayValue
    , "avg30Value" .= recordedValueAvg30Value
    ]


-- | Construct a value of type 'RecordedValue' (by applying it's required fields, if any)
mkRecordedValue :: RecordedValue
mkRecordedValue = RecordedValue { recordedValueRecordValue      = Nothing
                                , recordedValueRecordDate       = Nothing
                                , recordedValuePreviousDayValue = Nothing
                                , recordedValueAvg30Value       = Nothing
                                }

-- ** ShortInterest
-- | ShortInterest
data ShortInterest = ShortInterest
  { shortInterestSettlementDate :: !(Maybe Text) -- ^ "SettlementDate"
  , shortInterestSecurityName :: !(Maybe Text) -- ^ "SecurityName"
  , shortInterestCurrentShortIntereste :: !(Maybe Double) -- ^ "CurrentShortIntereste"
  , shortInterestPreviousShortInterest :: !(Maybe Double) -- ^ "PreviousShortInterest"
  , shortInterestPercentChange :: !(Maybe Double) -- ^ "PercentChange"
  , shortInterestAverageDailyVolume :: !(Maybe Double) -- ^ "AverageDailyVolume"
  , shortInterestDaystoCover :: !(Maybe Double) -- ^ "DaystoCover"
  , shortInterestStockAdjustmentFlag :: !(Maybe Text) -- ^ "StockAdjustmentFlag"
  , shortInterestRevisionFlag :: !(Maybe Text) -- ^ "RevisionFlag"
  , shortInterestSymbolinInetSymbology :: !(Maybe Text) -- ^ "SymbolinINETSymbology"
  , shortInterestSymbolinCqsSymbology :: !(Maybe Text) -- ^ "SymbolinCQSSymbology"
  , shortInterestSymbolinCmsSymbology :: !(Maybe Text) -- ^ "SymbolinCMSSymbology"
  , shortInterestNewIssueFlag :: !(Maybe Text) -- ^ "NewIssueFlag"
  , shortInterestCompanyName :: !(Maybe Text) -- ^ "CompanyName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ShortInterest
instance A.FromJSON ShortInterest where
  parseJSON = A.withObject "ShortInterest" $ \o ->
    ShortInterest
      <$> (o .:? "SettlementDate")
      <*> (o .:? "SecurityName")
      <*> (o .:? "CurrentShortIntereste")
      <*> (o .:? "PreviousShortInterest")
      <*> (o .:? "PercentChange")
      <*> (o .:? "AverageDailyVolume")
      <*> (o .:? "DaystoCover")
      <*> (o .:? "StockAdjustmentFlag")
      <*> (o .:? "RevisionFlag")
      <*> (o .:? "SymbolinINETSymbology")
      <*> (o .:? "SymbolinCQSSymbology")
      <*> (o .:? "SymbolinCMSSymbology")
      <*> (o .:? "NewIssueFlag")
      <*> (o .:? "CompanyName")

-- | ToJSON ShortInterest
instance A.ToJSON ShortInterest where
  toJSON ShortInterest {..} = _omitNulls
    [ "SettlementDate" .= shortInterestSettlementDate
    , "SecurityName" .= shortInterestSecurityName
    , "CurrentShortIntereste" .= shortInterestCurrentShortIntereste
    , "PreviousShortInterest" .= shortInterestPreviousShortInterest
    , "PercentChange" .= shortInterestPercentChange
    , "AverageDailyVolume" .= shortInterestAverageDailyVolume
    , "DaystoCover" .= shortInterestDaystoCover
    , "StockAdjustmentFlag" .= shortInterestStockAdjustmentFlag
    , "RevisionFlag" .= shortInterestRevisionFlag
    , "SymbolinINETSymbology" .= shortInterestSymbolinInetSymbology
    , "SymbolinCQSSymbology" .= shortInterestSymbolinCqsSymbology
    , "SymbolinCMSSymbology" .= shortInterestSymbolinCmsSymbology
    , "NewIssueFlag" .= shortInterestNewIssueFlag
    , "CompanyName" .= shortInterestCompanyName
    ]


-- | Construct a value of type 'ShortInterest' (by applying it's required fields, if any)
mkShortInterest :: ShortInterest
mkShortInterest = ShortInterest { shortInterestSettlementDate        = Nothing
                                , shortInterestSecurityName          = Nothing
                                , shortInterestCurrentShortIntereste = Nothing
                                , shortInterestPreviousShortInterest = Nothing
                                , shortInterestPercentChange         = Nothing
                                , shortInterestAverageDailyVolume    = Nothing
                                , shortInterestDaystoCover           = Nothing
                                , shortInterestStockAdjustmentFlag   = Nothing
                                , shortInterestRevisionFlag          = Nothing
                                , shortInterestSymbolinInetSymbology = Nothing
                                , shortInterestSymbolinCqsSymbology  = Nothing
                                , shortInterestSymbolinCmsSymbology  = Nothing
                                , shortInterestNewIssueFlag          = Nothing
                                , shortInterestCompanyName           = Nothing
                                }

-- ** Stats
-- | Stats
data Stats = Stats
  { statsAverageDailyVolume :: !(Maybe Double) -- ^ "averageDailyVolume"
  , statsAverageDailyRoutedVolume :: !(Maybe Double) -- ^ "averageDailyRoutedVolume"
  , statsAverageMarketShare :: !(Maybe Double) -- ^ "averageMarketShare"
  , statsAverageOrderSize :: !(Maybe Double) -- ^ "averageOrderSize"
  , statsAverageFillSize :: !(Maybe Double) -- ^ "averageFillSize"
  , statsBin100Percent :: !(Maybe Double) -- ^ "bin100Percent"
  , statsBin101Percent :: !(Maybe Double) -- ^ "bin101Percent"
  , statsBin200Percent :: !(Maybe Double) -- ^ "bin200Percent"
  , statsBin300Percent :: !(Maybe Double) -- ^ "bin300Percent"
  , statsBin400Percent :: !(Maybe Double) -- ^ "bin400Percent"
  , statsBin500Percent :: !(Maybe Double) -- ^ "bin500Percent"
  , statsBin1000Percent :: !(Maybe Double) -- ^ "bin1000Percent"
  , statsBin5000Percent :: !(Maybe Double) -- ^ "bin5000Percent"
  , statsBin10000Percent :: !(Maybe Double) -- ^ "bin10000Percent"
  , statsBin10000Trades :: !(Maybe Double) -- ^ "bin10000Trades"
  , statsBin20000Trades :: !(Maybe Double) -- ^ "bin20000Trades"
  , statsBin50000Trades :: !(Maybe Double) -- ^ "bin50000Trades"
  , statsUniqueSymbolsTraded :: !(Maybe Double) -- ^ "uniqueSymbolsTraded"
  , statsBlockPercent :: !(Maybe Double) -- ^ "blockPercent"
  , statsSelfCrossPercent :: !(Maybe Double) -- ^ "selfCrossPercent"
  , statsEtfPercent :: !(Maybe Double) -- ^ "etfPercent"
  , statsLargeCapPercent :: !(Maybe Double) -- ^ "largeCapPercent"
  , statsMidCapPercent :: !(Maybe Double) -- ^ "midCapPercent"
  , statsSmallCapPercent :: !(Maybe Double) -- ^ "smallCapPercent"
  , statsVenueArcxFirstWaveWeight :: !(Maybe Double) -- ^ "venueARCXFirstWaveWeight"
  , statsVenueBatsFirstWaveWeight :: !(Maybe Double) -- ^ "venueBATSFirstWaveWeight"
  , statsVenueBatyFirstWaveWeight :: !(Maybe Double) -- ^ "venueBATYFirstWaveWeight"
  , statsVenueEdgaFirstWaveWeight :: !(Maybe Double) -- ^ "venueEDGAFirstWaveWeight"
  , statsVenueEdgxFirstWaveWeight :: !(Maybe Double) -- ^ "venueEDGXFirstWaveWeight"
  , statsVenueOverallFirstWaveWeight :: !(Maybe Double) -- ^ "venueOverallFirstWaveWeight"
  , statsVenueXaseFirstWaveWeight :: !(Maybe Double) -- ^ "venueXASEFirstWaveWeight"
  , statsVenueXbosFirstWaveWeight :: !(Maybe Double) -- ^ "venueXBOSFirstWaveWeight"
  , statsVenueXchiFirstWaveWeight :: !(Maybe Double) -- ^ "venueXCHIFirstWaveWeight"
  , statsVenueXcisFirstWaveWeight :: !(Maybe Double) -- ^ "venueXCISFirstWaveWeight"
  , statsVenueXngsFirstWaveWeight :: !(Maybe Double) -- ^ "venueXNGSFirstWaveWeight"
  , statsVenueXnysFirstWaveWeight :: !(Maybe Double) -- ^ "venueXNYSFirstWaveWeight"
  , statsVenueXphlFirstWaveWeight :: !(Maybe Double) -- ^ "venueXPHLFirstWaveWeight"
  , statsVenueArcxFirstWaveRate :: !(Maybe Double) -- ^ "venueARCXFirstWaveRate"
  , statsVenueBatsFirstWaveRate :: !(Maybe Double) -- ^ "venueBATSFirstWaveRate"
  , statsVenueBatyFirstWaveRate :: !(Maybe Double) -- ^ "venueBATYFirstWaveRate"
  , statsVenueEdgaFirstWaveRate :: !(Maybe Double) -- ^ "venueEDGAFirstWaveRate"
  , statsVenueEdgxFirstWaveRate :: !(Maybe Double) -- ^ "venueEDGXFirstWaveRate"
  , statsVenueOverallFirstWaveRate :: !(Maybe Double) -- ^ "venueOverallFirstWaveRate"
  , statsVenueXaseFirstWaveRate :: !(Maybe Double) -- ^ "venueXASEFirstWaveRate"
  , statsVenueXbosFirstWaveRate :: !(Maybe Double) -- ^ "venueXBOSFirstWaveRate"
  , statsVenueXchiFirstWaveRate :: !(Maybe Double) -- ^ "venueXCHIFirstWaveRate"
  , statsVenueXcisFirstWaveRate :: !(Maybe Double) -- ^ "venueXCISFirstWaveRate"
  , statsVenueXngsFirstWaveRate :: !(Maybe Double) -- ^ "venueXNGSFirstWaveRate"
  , statsVenueXnysFirstWaveRate :: !(Maybe Double) -- ^ "venueXNYSFirstWaveRate"
  , statsVenueXphlFirstWaveRate :: !(Maybe Double) -- ^ "venueXPHLFirstWaveRate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Stats
instance A.FromJSON Stats where
  parseJSON = A.withObject "Stats" $ \o ->
    Stats
      <$> (o .:? "averageDailyVolume")
      <*> (o .:? "averageDailyRoutedVolume")
      <*> (o .:? "averageMarketShare")
      <*> (o .:? "averageOrderSize")
      <*> (o .:? "averageFillSize")
      <*> (o .:? "bin100Percent")
      <*> (o .:? "bin101Percent")
      <*> (o .:? "bin200Percent")
      <*> (o .:? "bin300Percent")
      <*> (o .:? "bin400Percent")
      <*> (o .:? "bin500Percent")
      <*> (o .:? "bin1000Percent")
      <*> (o .:? "bin5000Percent")
      <*> (o .:? "bin10000Percent")
      <*> (o .:? "bin10000Trades")
      <*> (o .:? "bin20000Trades")
      <*> (o .:? "bin50000Trades")
      <*> (o .:? "uniqueSymbolsTraded")
      <*> (o .:? "blockPercent")
      <*> (o .:? "selfCrossPercent")
      <*> (o .:? "etfPercent")
      <*> (o .:? "largeCapPercent")
      <*> (o .:? "midCapPercent")
      <*> (o .:? "smallCapPercent")
      <*> (o .:? "venueARCXFirstWaveWeight")
      <*> (o .:? "venueBATSFirstWaveWeight")
      <*> (o .:? "venueBATYFirstWaveWeight")
      <*> (o .:? "venueEDGAFirstWaveWeight")
      <*> (o .:? "venueEDGXFirstWaveWeight")
      <*> (o .:? "venueOverallFirstWaveWeight")
      <*> (o .:? "venueXASEFirstWaveWeight")
      <*> (o .:? "venueXBOSFirstWaveWeight")
      <*> (o .:? "venueXCHIFirstWaveWeight")
      <*> (o .:? "venueXCISFirstWaveWeight")
      <*> (o .:? "venueXNGSFirstWaveWeight")
      <*> (o .:? "venueXNYSFirstWaveWeight")
      <*> (o .:? "venueXPHLFirstWaveWeight")
      <*> (o .:? "venueARCXFirstWaveRate")
      <*> (o .:? "venueBATSFirstWaveRate")
      <*> (o .:? "venueBATYFirstWaveRate")
      <*> (o .:? "venueEDGAFirstWaveRate")
      <*> (o .:? "venueEDGXFirstWaveRate")
      <*> (o .:? "venueOverallFirstWaveRate")
      <*> (o .:? "venueXASEFirstWaveRate")
      <*> (o .:? "venueXBOSFirstWaveRate")
      <*> (o .:? "venueXCHIFirstWaveRate")
      <*> (o .:? "venueXCISFirstWaveRate")
      <*> (o .:? "venueXNGSFirstWaveRate")
      <*> (o .:? "venueXNYSFirstWaveRate")
      <*> (o .:? "venueXPHLFirstWaveRate")

-- | ToJSON Stats
instance A.ToJSON Stats where
  toJSON Stats {..} = _omitNulls
    [ "averageDailyVolume" .= statsAverageDailyVolume
    , "averageDailyRoutedVolume" .= statsAverageDailyRoutedVolume
    , "averageMarketShare" .= statsAverageMarketShare
    , "averageOrderSize" .= statsAverageOrderSize
    , "averageFillSize" .= statsAverageFillSize
    , "bin100Percent" .= statsBin100Percent
    , "bin101Percent" .= statsBin101Percent
    , "bin200Percent" .= statsBin200Percent
    , "bin300Percent" .= statsBin300Percent
    , "bin400Percent" .= statsBin400Percent
    , "bin500Percent" .= statsBin500Percent
    , "bin1000Percent" .= statsBin1000Percent
    , "bin5000Percent" .= statsBin5000Percent
    , "bin10000Percent" .= statsBin10000Percent
    , "bin10000Trades" .= statsBin10000Trades
    , "bin20000Trades" .= statsBin20000Trades
    , "bin50000Trades" .= statsBin50000Trades
    , "uniqueSymbolsTraded" .= statsUniqueSymbolsTraded
    , "blockPercent" .= statsBlockPercent
    , "selfCrossPercent" .= statsSelfCrossPercent
    , "etfPercent" .= statsEtfPercent
    , "largeCapPercent" .= statsLargeCapPercent
    , "midCapPercent" .= statsMidCapPercent
    , "smallCapPercent" .= statsSmallCapPercent
    , "venueARCXFirstWaveWeight" .= statsVenueArcxFirstWaveWeight
    , "venueBATSFirstWaveWeight" .= statsVenueBatsFirstWaveWeight
    , "venueBATYFirstWaveWeight" .= statsVenueBatyFirstWaveWeight
    , "venueEDGAFirstWaveWeight" .= statsVenueEdgaFirstWaveWeight
    , "venueEDGXFirstWaveWeight" .= statsVenueEdgxFirstWaveWeight
    , "venueOverallFirstWaveWeight" .= statsVenueOverallFirstWaveWeight
    , "venueXASEFirstWaveWeight" .= statsVenueXaseFirstWaveWeight
    , "venueXBOSFirstWaveWeight" .= statsVenueXbosFirstWaveWeight
    , "venueXCHIFirstWaveWeight" .= statsVenueXchiFirstWaveWeight
    , "venueXCISFirstWaveWeight" .= statsVenueXcisFirstWaveWeight
    , "venueXNGSFirstWaveWeight" .= statsVenueXngsFirstWaveWeight
    , "venueXNYSFirstWaveWeight" .= statsVenueXnysFirstWaveWeight
    , "venueXPHLFirstWaveWeight" .= statsVenueXphlFirstWaveWeight
    , "venueARCXFirstWaveRate" .= statsVenueArcxFirstWaveRate
    , "venueBATSFirstWaveRate" .= statsVenueBatsFirstWaveRate
    , "venueBATYFirstWaveRate" .= statsVenueBatyFirstWaveRate
    , "venueEDGAFirstWaveRate" .= statsVenueEdgaFirstWaveRate
    , "venueEDGXFirstWaveRate" .= statsVenueEdgxFirstWaveRate
    , "venueOverallFirstWaveRate" .= statsVenueOverallFirstWaveRate
    , "venueXASEFirstWaveRate" .= statsVenueXaseFirstWaveRate
    , "venueXBOSFirstWaveRate" .= statsVenueXbosFirstWaveRate
    , "venueXCHIFirstWaveRate" .= statsVenueXchiFirstWaveRate
    , "venueXCISFirstWaveRate" .= statsVenueXcisFirstWaveRate
    , "venueXNGSFirstWaveRate" .= statsVenueXngsFirstWaveRate
    , "venueXNYSFirstWaveRate" .= statsVenueXnysFirstWaveRate
    , "venueXPHLFirstWaveRate" .= statsVenueXphlFirstWaveRate
    ]


-- | Construct a value of type 'Stats' (by applying it's required fields, if any)
mkStats :: Stats
mkStats = Stats { statsAverageDailyVolume          = Nothing
                , statsAverageDailyRoutedVolume    = Nothing
                , statsAverageMarketShare          = Nothing
                , statsAverageOrderSize            = Nothing
                , statsAverageFillSize             = Nothing
                , statsBin100Percent               = Nothing
                , statsBin101Percent               = Nothing
                , statsBin200Percent               = Nothing
                , statsBin300Percent               = Nothing
                , statsBin400Percent               = Nothing
                , statsBin500Percent               = Nothing
                , statsBin1000Percent              = Nothing
                , statsBin5000Percent              = Nothing
                , statsBin10000Percent             = Nothing
                , statsBin10000Trades              = Nothing
                , statsBin20000Trades              = Nothing
                , statsBin50000Trades              = Nothing
                , statsUniqueSymbolsTraded         = Nothing
                , statsBlockPercent                = Nothing
                , statsSelfCrossPercent            = Nothing
                , statsEtfPercent                  = Nothing
                , statsLargeCapPercent             = Nothing
                , statsMidCapPercent               = Nothing
                , statsSmallCapPercent             = Nothing
                , statsVenueArcxFirstWaveWeight    = Nothing
                , statsVenueBatsFirstWaveWeight    = Nothing
                , statsVenueBatyFirstWaveWeight    = Nothing
                , statsVenueEdgaFirstWaveWeight    = Nothing
                , statsVenueEdgxFirstWaveWeight    = Nothing
                , statsVenueOverallFirstWaveWeight = Nothing
                , statsVenueXaseFirstWaveWeight    = Nothing
                , statsVenueXbosFirstWaveWeight    = Nothing
                , statsVenueXchiFirstWaveWeight    = Nothing
                , statsVenueXcisFirstWaveWeight    = Nothing
                , statsVenueXngsFirstWaveWeight    = Nothing
                , statsVenueXnysFirstWaveWeight    = Nothing
                , statsVenueXphlFirstWaveWeight    = Nothing
                , statsVenueArcxFirstWaveRate      = Nothing
                , statsVenueBatsFirstWaveRate      = Nothing
                , statsVenueBatyFirstWaveRate      = Nothing
                , statsVenueEdgaFirstWaveRate      = Nothing
                , statsVenueEdgxFirstWaveRate      = Nothing
                , statsVenueOverallFirstWaveRate   = Nothing
                , statsVenueXaseFirstWaveRate      = Nothing
                , statsVenueXbosFirstWaveRate      = Nothing
                , statsVenueXchiFirstWaveRate      = Nothing
                , statsVenueXcisFirstWaveRate      = Nothing
                , statsVenueXngsFirstWaveRate      = Nothing
                , statsVenueXnysFirstWaveRate      = Nothing
                , statsVenueXphlFirstWaveRate      = Nothing
                }

-- ** SystemEvent
-- | SystemEvent
data SystemEvent = SystemEvent
  { systemEventSystemEvent :: !(Maybe E'SystemEvent) -- ^ "systemEvent" - The System event message is used to indicate events that apply to the market or the data feed. There will be a single message disseminated  per channel for each System Event type within a given trading  session. values:   * &#x60;O&#x60; - start of message   * &#x60;S&#x60; - start of system hours   * &#x60;R&#x60; - start of regular market hours   * &#x60;M&#x60; - end of regular market hours   * &#x60;E&#x60; - end of system hours   * &#x60;C&#x60; - end of message 
  , systemEventTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemEvent
instance A.FromJSON SystemEvent where
  parseJSON = A.withObject "SystemEvent"
    $ \o -> SystemEvent <$> (o .:? "systemEvent") <*> (o .:? "timestamp")

-- | ToJSON SystemEvent
instance A.ToJSON SystemEvent where
  toJSON SystemEvent {..} = _omitNulls
    [ "systemEvent" .= systemEventSystemEvent
    , "timestamp" .= systemEventTimestamp
    ]


-- | Construct a value of type 'SystemEvent' (by applying it's required fields, if any)
mkSystemEvent :: SystemEvent
mkSystemEvent = SystemEvent { systemEventSystemEvent = Nothing
                            , systemEventTimestamp   = Nothing
                            }

-- ** TimestampedValue
-- | TimestampedValue
data TimestampedValue = TimestampedValue
  { timestampedValueValue :: !(Maybe Double) -- ^ "value"
  , timestampedValueLastUpdated :: !(Maybe Double) -- ^ "lastUpdated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TimestampedValue
instance A.FromJSON TimestampedValue where
  parseJSON = A.withObject "TimestampedValue"
    $ \o -> TimestampedValue <$> (o .:? "value") <*> (o .:? "lastUpdated")

-- | ToJSON TimestampedValue
instance A.ToJSON TimestampedValue where
  toJSON TimestampedValue {..} = _omitNulls
    [ "value" .= timestampedValueValue
    , "lastUpdated" .= timestampedValueLastUpdated
    ]


-- | Construct a value of type 'TimestampedValue' (by applying it's required fields, if any)
mkTimestampedValue :: TimestampedValue
mkTimestampedValue = TimestampedValue { timestampedValueValue       = Nothing
                                      , timestampedValueLastUpdated = Nothing
                                      }

-- ** TodayEarnings
-- | TodayEarnings
data TodayEarnings = TodayEarnings
  { todayEarningsActualEps :: !(Maybe Double) -- ^ "actualEPS" - Actual earnings per share for the period
  , todayEarningsConsensusEps :: !(Maybe Double) -- ^ "consensusEPS" - Consensus EPS estimate trend for the period
  , todayEarningsEstimatedEps :: !(Maybe Double) -- ^ "estimatedEPS" - Earinings per share estimate for the period
  , todayEarningsAnnounceTime :: !(Maybe Text) -- ^ "announceTime" - Time of earnings announcement:   * BTO &#x3D; before open   * DMT &#x3D; during trading   * AMC &#x3D; after close 
  , todayEarningsNumberOfEstimates :: !(Maybe Double) -- ^ "numberOfEstimates" - Number of estimates for the period
  , todayEarningsEpsSurpriseDollar :: !(Maybe Double) -- ^ "EPSSurpriseDollar" - Dollar amount of EPS surprise for the period
  , todayEarningsEpsReportDate :: !(Maybe Date) -- ^ "EPSReportDate" - Expected eariings report date &#x60;YYYY-MM-DD&#x60;
  , todayEarningsFiscalPeriod :: !(Maybe Text) -- ^ "fiscalPeriod" - The fiscal quarter the earnings data applies to &#x60;Q# YYYY&#x60;
  , todayEarningsFiscalEndDate :: !(Maybe Date) -- ^ "fiscalEndDate" - Date representing the company fiscal quarter end &#x60;YYYY-MM-DD&#x60;
  , todayEarningsYearAgo :: !(Maybe Double) -- ^ "yearAgo" - Represents the EPS of the quarter a year ago
  , todayEarningsYearAgoChangePercent :: !(Maybe Double) -- ^ "yearAgoChangePercent" - Represents the percent difference between the quarter a year ago &#x60;actualEPS&#x60; and current period &#x60;actualEPS&#x60;.
  , todayEarningsEstimatedChangePercent :: !(Maybe Double) -- ^ "estimatedChangePercent" - Represents the percent difference between the quarter a year ago &#x60;actualEPS&#x60; and current period &#x60;estimatedEPS&#x60;
  , todayEarningsSymbolId :: !(Maybe Double) -- ^ "symbolId" - Represents the IEX id for the stock
  , todayEarningsSymbol :: !(Maybe Text) -- ^ "symbol"
  , todayEarningsQuote :: !(Maybe Quote) -- ^ "quote"
  , todayEarningsHeadline :: !(Maybe Text) -- ^ "headline" - Look back of the last few news items and returns the headline of an article that mentions the earnings result.  Useful for displaying the result of an earnings announcement before the data is available in the API. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TodayEarnings
instance A.FromJSON TodayEarnings where
  parseJSON = A.withObject "TodayEarnings" $ \o ->
    TodayEarnings
      <$> (o .:? "actualEPS")
      <*> (o .:? "consensusEPS")
      <*> (o .:? "estimatedEPS")
      <*> (o .:? "announceTime")
      <*> (o .:? "numberOfEstimates")
      <*> (o .:? "EPSSurpriseDollar")
      <*> (o .:? "EPSReportDate")
      <*> (o .:? "fiscalPeriod")
      <*> (o .:? "fiscalEndDate")
      <*> (o .:? "yearAgo")
      <*> (o .:? "yearAgoChangePercent")
      <*> (o .:? "estimatedChangePercent")
      <*> (o .:? "symbolId")
      <*> (o .:? "symbol")
      <*> (o .:? "quote")
      <*> (o .:? "headline")

-- | ToJSON TodayEarnings
instance A.ToJSON TodayEarnings where
  toJSON TodayEarnings {..} = _omitNulls
    [ "actualEPS" .= todayEarningsActualEps
    , "consensusEPS" .= todayEarningsConsensusEps
    , "estimatedEPS" .= todayEarningsEstimatedEps
    , "announceTime" .= todayEarningsAnnounceTime
    , "numberOfEstimates" .= todayEarningsNumberOfEstimates
    , "EPSSurpriseDollar" .= todayEarningsEpsSurpriseDollar
    , "EPSReportDate" .= todayEarningsEpsReportDate
    , "fiscalPeriod" .= todayEarningsFiscalPeriod
    , "fiscalEndDate" .= todayEarningsFiscalEndDate
    , "yearAgo" .= todayEarningsYearAgo
    , "yearAgoChangePercent" .= todayEarningsYearAgoChangePercent
    , "estimatedChangePercent" .= todayEarningsEstimatedChangePercent
    , "symbolId" .= todayEarningsSymbolId
    , "symbol" .= todayEarningsSymbol
    , "quote" .= todayEarningsQuote
    , "headline" .= todayEarningsHeadline
    ]


-- | Construct a value of type 'TodayEarnings' (by applying it's required fields, if any)
mkTodayEarnings :: TodayEarnings
mkTodayEarnings = TodayEarnings { todayEarningsActualEps              = Nothing
                                , todayEarningsConsensusEps           = Nothing
                                , todayEarningsEstimatedEps           = Nothing
                                , todayEarningsAnnounceTime           = Nothing
                                , todayEarningsNumberOfEstimates      = Nothing
                                , todayEarningsEpsSurpriseDollar      = Nothing
                                , todayEarningsEpsReportDate          = Nothing
                                , todayEarningsFiscalPeriod           = Nothing
                                , todayEarningsFiscalEndDate          = Nothing
                                , todayEarningsYearAgo                = Nothing
                                , todayEarningsYearAgoChangePercent   = Nothing
                                , todayEarningsEstimatedChangePercent = Nothing
                                , todayEarningsSymbolId               = Nothing
                                , todayEarningsSymbol                 = Nothing
                                , todayEarningsQuote                  = Nothing
                                , todayEarningsHeadline               = Nothing
                                }

-- ** TodayEarningsAllOf
-- | TodayEarningsAllOf
data TodayEarningsAllOf = TodayEarningsAllOf
  { todayEarningsAllOfSymbol :: !(Maybe Text) -- ^ "symbol"
  , todayEarningsAllOfQuote :: !(Maybe Quote) -- ^ "quote"
  , todayEarningsAllOfHeadline :: !(Maybe Text) -- ^ "headline" - Look back of the last few news items and returns the headline of an article that mentions the earnings result.  Useful for displaying the result of an earnings announcement before the data is available in the API. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TodayEarningsAllOf
instance A.FromJSON TodayEarningsAllOf where
  parseJSON = A.withObject "TodayEarningsAllOf" $ \o ->
    TodayEarningsAllOf
      <$> (o .:? "symbol")
      <*> (o .:? "quote")
      <*> (o .:? "headline")

-- | ToJSON TodayEarningsAllOf
instance A.ToJSON TodayEarningsAllOf where
  toJSON TodayEarningsAllOf {..} = _omitNulls
    [ "symbol" .= todayEarningsAllOfSymbol
    , "quote" .= todayEarningsAllOfQuote
    , "headline" .= todayEarningsAllOfHeadline
    ]


-- | Construct a value of type 'TodayEarningsAllOf' (by applying it's required fields, if any)
mkTodayEarningsAllOf :: TodayEarningsAllOf
mkTodayEarningsAllOf = TodayEarningsAllOf
  { todayEarningsAllOfSymbol   = Nothing
  , todayEarningsAllOfQuote    = Nothing
  , todayEarningsAllOfHeadline = Nothing
  }

-- ** Trade
-- | Trade
data Trade = Trade
  { tradePrice :: !(Maybe Double) -- ^ "price"
  , tradeSize :: !(Maybe Double) -- ^ "size"
  , tradeTradeId :: !(Maybe Double) -- ^ "tradeId"
  , tradeIsIso :: !(Maybe Bool) -- ^ "isISO"
  , tradeIsOddLot :: !(Maybe Bool) -- ^ "isOddLot"
  , tradeIsOutsideRegularHours :: !(Maybe Bool) -- ^ "isOutsideRegularHours"
  , tradeIsSinglePriceCross :: !(Maybe Bool) -- ^ "isSinglePriceCross"
  , tradeIsTradeThroughExempt :: !(Maybe Bool) -- ^ "isTradeThroughExempt"
  , tradeTimestamp :: !(Maybe Double) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Trade
instance A.FromJSON Trade where
  parseJSON = A.withObject "Trade" $ \o ->
    Trade
      <$> (o .:? "price")
      <*> (o .:? "size")
      <*> (o .:? "tradeId")
      <*> (o .:? "isISO")
      <*> (o .:? "isOddLot")
      <*> (o .:? "isOutsideRegularHours")
      <*> (o .:? "isSinglePriceCross")
      <*> (o .:? "isTradeThroughExempt")
      <*> (o .:? "timestamp")

-- | ToJSON Trade
instance A.ToJSON Trade where
  toJSON Trade {..} = _omitNulls
    [ "price" .= tradePrice
    , "size" .= tradeSize
    , "tradeId" .= tradeTradeId
    , "isISO" .= tradeIsIso
    , "isOddLot" .= tradeIsOddLot
    , "isOutsideRegularHours" .= tradeIsOutsideRegularHours
    , "isSinglePriceCross" .= tradeIsSinglePriceCross
    , "isTradeThroughExempt" .= tradeIsTradeThroughExempt
    , "timestamp" .= tradeTimestamp
    ]


-- | Construct a value of type 'Trade' (by applying it's required fields, if any)
mkTrade :: Trade
mkTrade = Trade { tradePrice                 = Nothing
                , tradeSize                  = Nothing
                , tradeTradeId               = Nothing
                , tradeIsIso                 = Nothing
                , tradeIsOddLot              = Nothing
                , tradeIsOutsideRegularHours = Nothing
                , tradeIsSinglePriceCross    = Nothing
                , tradeIsTradeThroughExempt  = Nothing
                , tradeTimestamp             = Nothing
                }


-- * Enums


-- ** E'AuctionType

-- | Enum of 'Text' .
-- refers to the auction type
data E'AuctionType
  = E'AuctionType'Open -- ^ @"Open"@
  | E'AuctionType'Close -- ^ @"Close"@
  | E'AuctionType'Halt_Volatility -- ^ @"Halt Volatility"@
  | E'AuctionType'IPO -- ^ @"IPO"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AuctionType where
  toJSON = A.toJSON . fromE'AuctionType
instance A.FromJSON E'AuctionType where
  parseJSON o =
    P.either P.fail (pure . P.id) . toE'AuctionType =<< A.parseJSON o
instance WH.ToHttpApiData E'AuctionType where
  toQueryParam = WH.toQueryParam . fromE'AuctionType
instance WH.FromHttpApiData E'AuctionType where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AuctionType
instance MimeRender MimeMultipartFormData E'AuctionType where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AuctionType' enum
fromE'AuctionType :: E'AuctionType -> Text
fromE'AuctionType = \case
  E'AuctionType'Open            -> "Open"
  E'AuctionType'Close           -> "Close"
  E'AuctionType'Halt_Volatility -> "Halt Volatility"
  E'AuctionType'IPO             -> "IPO"

-- | parse 'E'AuctionType' enum
toE'AuctionType :: Text -> P.Either String E'AuctionType
toE'AuctionType = \case
  "Open"            -> P.Right E'AuctionType'Open
  "Close"           -> P.Right E'AuctionType'Close
  "Halt Volatility" -> P.Right E'AuctionType'Halt_Volatility
  "IPO"             -> P.Right E'AuctionType'IPO
  s -> P.Left $ "toE'AuctionType: enum parse failure: " P.++ P.show s


-- ** E'CalculationPrice

-- | Enum of 'Text' .
-- Refers to the source of the latest price
data E'CalculationPrice
  = E'CalculationPrice'Tops -- ^ @"tops"@
  | E'CalculationPrice'Sip -- ^ @"sip"@
  | E'CalculationPrice'Previousclose -- ^ @"previousclose"@
  | E'CalculationPrice'Close -- ^ @"close"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CalculationPrice where
  toJSON = A.toJSON . fromE'CalculationPrice
instance A.FromJSON E'CalculationPrice where
  parseJSON o =
    P.either P.fail (pure . P.id) . toE'CalculationPrice =<< A.parseJSON o
instance WH.ToHttpApiData E'CalculationPrice where
  toQueryParam = WH.toQueryParam . fromE'CalculationPrice
instance WH.FromHttpApiData E'CalculationPrice where
  parseQueryParam o =
    WH.parseQueryParam o >>= P.left T.pack . toE'CalculationPrice
instance MimeRender MimeMultipartFormData E'CalculationPrice where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CalculationPrice' enum
fromE'CalculationPrice :: E'CalculationPrice -> Text
fromE'CalculationPrice = \case
  E'CalculationPrice'Tops          -> "tops"
  E'CalculationPrice'Sip           -> "sip"
  E'CalculationPrice'Previousclose -> "previousclose"
  E'CalculationPrice'Close         -> "close"

-- | parse 'E'CalculationPrice' enum
toE'CalculationPrice :: Text -> P.Either String E'CalculationPrice
toE'CalculationPrice = \case
  "tops"          -> P.Right E'CalculationPrice'Tops
  "sip"           -> P.Right E'CalculationPrice'Sip
  "previousclose" -> P.Right E'CalculationPrice'Previousclose
  "close"         -> P.Right E'CalculationPrice'Close
  s -> P.Left $ "toE'CalculationPrice: enum parse failure: " P.++ P.show s


-- ** E'Flag

-- | Enum of 'Text' .
-- Refers to the dividend flag:   * LI = Liquidation, instrument liquidates   * PR = Proceeds of a sale of rights or shares   * RE = Redemption of rights   * AC = Accrued dividend   * AR = Payment in arrears   * AD = Additional payment   * EX = Extra payment   * SP = Special dividend   * YE = Year end   * UR = Unknown recordDate   * SU = Regular divdend is suspended 
data E'Flag
  = E'Flag'FI -- ^ @"FI"@
  | E'Flag'LI -- ^ @"LI"@
  | E'Flag'PR -- ^ @"PR"@
  | E'Flag'RE -- ^ @"RE"@
  | E'Flag'AC -- ^ @"AC"@
  | E'Flag'AR -- ^ @"AR"@
  | E'Flag'AD -- ^ @"AD"@
  | E'Flag'EX -- ^ @"EX"@
  | E'Flag'SP -- ^ @"SP"@
  | E'Flag'YE -- ^ @"YE"@
  | E'Flag'UR -- ^ @"UR"@
  | E'Flag'SU -- ^ @"SU"@
  | E'Flag'Empty -- ^ @""@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Flag where
  toJSON = A.toJSON . fromE'Flag
instance A.FromJSON E'Flag where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Flag =<< A.parseJSON o
instance WH.ToHttpApiData E'Flag where
  toQueryParam = WH.toQueryParam . fromE'Flag
instance WH.FromHttpApiData E'Flag where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Flag
instance MimeRender MimeMultipartFormData E'Flag where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Flag' enum
fromE'Flag :: E'Flag -> Text
fromE'Flag = \case
  E'Flag'FI    -> "FI"
  E'Flag'LI    -> "LI"
  E'Flag'PR    -> "PR"
  E'Flag'RE    -> "RE"
  E'Flag'AC    -> "AC"
  E'Flag'AR    -> "AR"
  E'Flag'AD    -> "AD"
  E'Flag'EX    -> "EX"
  E'Flag'SP    -> "SP"
  E'Flag'YE    -> "YE"
  E'Flag'UR    -> "UR"
  E'Flag'SU    -> "SU"
  E'Flag'Empty -> ""

-- | parse 'E'Flag' enum
toE'Flag :: Text -> P.Either String E'Flag
toE'Flag = \case
  "FI" -> P.Right E'Flag'FI
  "LI" -> P.Right E'Flag'LI
  "PR" -> P.Right E'Flag'PR
  "RE" -> P.Right E'Flag'RE
  "AC" -> P.Right E'Flag'AC
  "AR" -> P.Right E'Flag'AR
  "AD" -> P.Right E'Flag'AD
  "EX" -> P.Right E'Flag'EX
  "SP" -> P.Right E'Flag'SP
  "YE" -> P.Right E'Flag'YE
  "UR" -> P.Right E'Flag'UR
  "SU" -> P.Right E'Flag'SU
  ""   -> P.Right E'Flag'Empty
  s    -> P.Left $ "toE'Flag: enum parse failure: " P.++ P.show s


-- ** E'Format

-- | Enum of 'Text'
data E'Format
  = E'Format'Csv -- ^ @"csv"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Format where
  toJSON = A.toJSON . fromE'Format
instance A.FromJSON E'Format where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Format =<< A.parseJSON o
instance WH.ToHttpApiData E'Format where
  toQueryParam = WH.toQueryParam . fromE'Format
instance WH.FromHttpApiData E'Format where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Format
instance MimeRender MimeMultipartFormData E'Format where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Format' enum
fromE'Format :: E'Format -> Text
fromE'Format = \case
  E'Format'Csv -> "csv"

-- | parse 'E'Format' enum
toE'Format :: Text -> P.Either String E'Format
toE'Format = \case
  "csv" -> P.Right E'Format'Csv
  s     -> P.Left $ "toE'Format: enum parse failure: " P.++ P.show s


-- ** E'Format2

-- | Enum of 'Text'
data E'Format2
  = E'Format2'Csv -- ^ @"csv"@
  | E'Format2'Psv -- ^ @"psv"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Format2 where
  toJSON = A.toJSON . fromE'Format2
instance A.FromJSON E'Format2 where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Format2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Format2 where
  toQueryParam = WH.toQueryParam . fromE'Format2
instance WH.FromHttpApiData E'Format2 where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Format2
instance MimeRender MimeMultipartFormData E'Format2 where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Format2' enum
fromE'Format2 :: E'Format2 -> Text
fromE'Format2 = \case
  E'Format2'Csv -> "csv"
  E'Format2'Psv -> "psv"

-- | parse 'E'Format2' enum
toE'Format2 :: Text -> P.Either String E'Format2
toE'Format2 = \case
  "csv" -> P.Right E'Format2'Csv
  "psv" -> P.Right E'Format2'Psv
  s     -> P.Left $ "toE'Format2: enum parse failure: " P.++ P.show s


-- ** E'Inner

-- | Enum of 'Text'
data E'Inner
  = E'Inner'Book -- ^ @"book"@
  | E'Inner'Chart -- ^ @"chart"@
  | E'Inner'Company -- ^ @"company"@
  | E'Inner'Delayed_quote -- ^ @"delayed-quote"@
  | E'Inner'Dividends -- ^ @"dividends"@
  | E'Inner'Earnings -- ^ @"earnings"@
  | E'Inner'Effective_spread -- ^ @"effective-spread"@
  | E'Inner'Financials -- ^ @"financials"@
  | E'Inner'Short_interest -- ^ @"short-interest"@
  | E'Inner'Stats -- ^ @"stats"@
  | E'Inner'Largest_trades -- ^ @"largest-trades"@
  | E'Inner'Logo -- ^ @"logo"@
  | E'Inner'News -- ^ @"news"@
  | E'Inner'Ohlc -- ^ @"ohlc"@
  | E'Inner'Peers -- ^ @"peers"@
  | E'Inner'Previous -- ^ @"previous"@
  | E'Inner'Price -- ^ @"price"@
  | E'Inner'Quote -- ^ @"quote"@
  | E'Inner'Relevant -- ^ @"relevant"@
  | E'Inner'Splits -- ^ @"splits"@
  | E'Inner'Time_series -- ^ @"time-series"@
  | E'Inner'Volume_by_venue -- ^ @"volume-by-venue"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Inner where
  toJSON = A.toJSON . fromE'Inner
instance A.FromJSON E'Inner where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Inner =<< A.parseJSON o
instance WH.ToHttpApiData E'Inner where
  toQueryParam = WH.toQueryParam . fromE'Inner
instance WH.FromHttpApiData E'Inner where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Inner
instance MimeRender MimeMultipartFormData E'Inner where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Inner' enum
fromE'Inner :: E'Inner -> Text
fromE'Inner = \case
  E'Inner'Book             -> "book"
  E'Inner'Chart            -> "chart"
  E'Inner'Company          -> "company"
  E'Inner'Delayed_quote    -> "delayed-quote"
  E'Inner'Dividends        -> "dividends"
  E'Inner'Earnings         -> "earnings"
  E'Inner'Effective_spread -> "effective-spread"
  E'Inner'Financials       -> "financials"
  E'Inner'Short_interest   -> "short-interest"
  E'Inner'Stats            -> "stats"
  E'Inner'Largest_trades   -> "largest-trades"
  E'Inner'Logo             -> "logo"
  E'Inner'News             -> "news"
  E'Inner'Ohlc             -> "ohlc"
  E'Inner'Peers            -> "peers"
  E'Inner'Previous         -> "previous"
  E'Inner'Price            -> "price"
  E'Inner'Quote            -> "quote"
  E'Inner'Relevant         -> "relevant"
  E'Inner'Splits           -> "splits"
  E'Inner'Time_series      -> "time-series"
  E'Inner'Volume_by_venue  -> "volume-by-venue"

-- | parse 'E'Inner' enum
toE'Inner :: Text -> P.Either String E'Inner
toE'Inner = \case
  "book"             -> P.Right E'Inner'Book
  "chart"            -> P.Right E'Inner'Chart
  "company"          -> P.Right E'Inner'Company
  "delayed-quote"    -> P.Right E'Inner'Delayed_quote
  "dividends"        -> P.Right E'Inner'Dividends
  "earnings"         -> P.Right E'Inner'Earnings
  "effective-spread" -> P.Right E'Inner'Effective_spread
  "financials"       -> P.Right E'Inner'Financials
  "short-interest"   -> P.Right E'Inner'Short_interest
  "stats"            -> P.Right E'Inner'Stats
  "largest-trades"   -> P.Right E'Inner'Largest_trades
  "logo"             -> P.Right E'Inner'Logo
  "news"             -> P.Right E'Inner'News
  "ohlc"             -> P.Right E'Inner'Ohlc
  "peers"            -> P.Right E'Inner'Peers
  "previous"         -> P.Right E'Inner'Previous
  "price"            -> P.Right E'Inner'Price
  "quote"            -> P.Right E'Inner'Quote
  "relevant"         -> P.Right E'Inner'Relevant
  "splits"           -> P.Right E'Inner'Splits
  "time-series"      -> P.Right E'Inner'Time_series
  "volume-by-venue"  -> P.Right E'Inner'Volume_by_venue
  s                  -> P.Left $ "toE'Inner: enum parse failure: " P.++ P.show s


-- ** E'IssueType

-- | Enum of 'Text' .
-- refers to the common issue type of the stock \\n * ad - American Depository Receipt (ADRs) * re - Real Estate Investment Trust (REITs) * ce - Closed end fund (Stock and Bond Fund) * si - Secondary issue * lp - Limited Partnerships * cs - Common Stock * et - Exchange Traded Fund (ETF) * (blank) - Not available, i.e. Warrant, Note, or (non-filing) Closed Ended Funds 
data E'IssueType
  = E'IssueType'Ad -- ^ @"ad"@
  | E'IssueType'Re -- ^ @"re"@
  | E'IssueType'Ce -- ^ @"ce"@
  | E'IssueType'Si -- ^ @"si"@
  | E'IssueType'Lp -- ^ @"lp"@
  | E'IssueType'Cs -- ^ @"cs"@
  | E'IssueType'Et -- ^ @"et"@
  | E'IssueType'Empty -- ^ @""@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'IssueType where
  toJSON = A.toJSON . fromE'IssueType
instance A.FromJSON E'IssueType where
  parseJSON o = P.either P.fail (pure . P.id) . toE'IssueType =<< A.parseJSON o
instance WH.ToHttpApiData E'IssueType where
  toQueryParam = WH.toQueryParam . fromE'IssueType
instance WH.FromHttpApiData E'IssueType where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'IssueType
instance MimeRender MimeMultipartFormData E'IssueType where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'IssueType' enum
fromE'IssueType :: E'IssueType -> Text
fromE'IssueType = \case
  E'IssueType'Ad    -> "ad"
  E'IssueType'Re    -> "re"
  E'IssueType'Ce    -> "ce"
  E'IssueType'Si    -> "si"
  E'IssueType'Lp    -> "lp"
  E'IssueType'Cs    -> "cs"
  E'IssueType'Et    -> "et"
  E'IssueType'Empty -> ""

-- | parse 'E'IssueType' enum
toE'IssueType :: Text -> P.Either String E'IssueType
toE'IssueType = \case
  "ad" -> P.Right E'IssueType'Ad
  "re" -> P.Right E'IssueType'Re
  "ce" -> P.Right E'IssueType'Ce
  "si" -> P.Right E'IssueType'Si
  "lp" -> P.Right E'IssueType'Lp
  "cs" -> P.Right E'IssueType'Cs
  "et" -> P.Right E'IssueType'Et
  ""   -> P.Right E'IssueType'Empty
  s    -> P.Left $ "toE'IssueType: enum parse failure: " P.++ P.show s


-- ** E'LatestSource

-- | Enum of 'Text' .
-- Refers to the source of `latestPrice`.
data E'LatestSource
  = E'LatestSource'IEX_real_time_price -- ^ @"IEX real time price"@
  | E'LatestSource'15_minute_delayed_price -- ^ @"15 minute delayed price"@
  | E'LatestSource'Close -- ^ @"Close"@
  | E'LatestSource'Previous_close -- ^ @"Previous close"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'LatestSource where
  toJSON = A.toJSON . fromE'LatestSource
instance A.FromJSON E'LatestSource where
  parseJSON o =
    P.either P.fail (pure . P.id) . toE'LatestSource =<< A.parseJSON o
instance WH.ToHttpApiData E'LatestSource where
  toQueryParam = WH.toQueryParam . fromE'LatestSource
instance WH.FromHttpApiData E'LatestSource where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'LatestSource
instance MimeRender MimeMultipartFormData E'LatestSource where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'LatestSource' enum
fromE'LatestSource :: E'LatestSource -> Text
fromE'LatestSource = \case
  E'LatestSource'IEX_real_time_price     -> "IEX real time price"
  E'LatestSource'15_minute_delayed_price -> "15 minute delayed price"
  E'LatestSource'Close                   -> "Close"
  E'LatestSource'Previous_close          -> "Previous close"

-- | parse 'E'LatestSource' enum
toE'LatestSource :: Text -> P.Either String E'LatestSource
toE'LatestSource = \case
  "IEX real time price"     -> P.Right E'LatestSource'IEX_real_time_price
  "15 minute delayed price" -> P.Right E'LatestSource'15_minute_delayed_price
  "Close"                   -> P.Right E'LatestSource'Close
  "Previous close"          -> P.Right E'LatestSource'Previous_close
  s -> P.Left $ "toE'LatestSource: enum parse failure: " P.++ P.show s


-- ** E'ListType

-- | Enum of 'Text'
data E'ListType
  = E'ListType'Mostactive -- ^ @"mostactive"@
  | E'ListType'Gainers -- ^ @"gainers"@
  | E'ListType'Losers -- ^ @"losers"@
  | E'ListType'Iexvolume -- ^ @"iexvolume"@
  | E'ListType'Iexpercent -- ^ @"iexpercent"@
  | E'ListType'Infocus -- ^ @"infocus"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ListType where
  toJSON = A.toJSON . fromE'ListType
instance A.FromJSON E'ListType where
  parseJSON o = P.either P.fail (pure . P.id) . toE'ListType =<< A.parseJSON o
instance WH.ToHttpApiData E'ListType where
  toQueryParam = WH.toQueryParam . fromE'ListType
instance WH.FromHttpApiData E'ListType where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ListType
instance MimeRender MimeMultipartFormData E'ListType where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ListType' enum
fromE'ListType :: E'ListType -> Text
fromE'ListType = \case
  E'ListType'Mostactive -> "mostactive"
  E'ListType'Gainers    -> "gainers"
  E'ListType'Losers     -> "losers"
  E'ListType'Iexvolume  -> "iexvolume"
  E'ListType'Iexpercent -> "iexpercent"
  E'ListType'Infocus    -> "infocus"

-- | parse 'E'ListType' enum
toE'ListType :: Text -> P.Either String E'ListType
toE'ListType = \case
  "mostactive" -> P.Right E'ListType'Mostactive
  "gainers"    -> P.Right E'ListType'Gainers
  "losers"     -> P.Right E'ListType'Losers
  "iexvolume"  -> P.Right E'ListType'Iexvolume
  "iexpercent" -> P.Right E'ListType'Iexpercent
  "infocus"    -> P.Right E'ListType'Infocus
  s            -> P.Left $ "toE'ListType: enum parse failure: " P.++ P.show s


-- ** E'Period

-- | Enum of 'Text'
data E'Period
  = E'Period'Annual -- ^ @"annual"@
  | E'Period'Quarter -- ^ @"quarter"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Period where
  toJSON = A.toJSON . fromE'Period
instance A.FromJSON E'Period where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Period =<< A.parseJSON o
instance WH.ToHttpApiData E'Period where
  toQueryParam = WH.toQueryParam . fromE'Period
instance WH.FromHttpApiData E'Period where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Period
instance MimeRender MimeMultipartFormData E'Period where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Period' enum
fromE'Period :: E'Period -> Text
fromE'Period = \case
  E'Period'Annual  -> "annual"
  E'Period'Quarter -> "quarter"

-- | parse 'E'Period' enum
toE'Period :: Text -> P.Either String E'Period
toE'Period = \case
  "annual"  -> P.Right E'Period'Annual
  "quarter" -> P.Right E'Period'Quarter
  s         -> P.Left $ "toE'Period: enum parse failure: " P.++ P.show s


-- ** E'PriceType

-- | Enum of 'Text'
data E'PriceType
  = E'PriceType'Open -- ^ @"Open"@
  | E'PriceType'Close -- ^ @"Close"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PriceType where
  toJSON = A.toJSON . fromE'PriceType
instance A.FromJSON E'PriceType where
  parseJSON o = P.either P.fail (pure . P.id) . toE'PriceType =<< A.parseJSON o
instance WH.ToHttpApiData E'PriceType where
  toQueryParam = WH.toQueryParam . fromE'PriceType
instance WH.FromHttpApiData E'PriceType where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PriceType
instance MimeRender MimeMultipartFormData E'PriceType where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PriceType' enum
fromE'PriceType :: E'PriceType -> Text
fromE'PriceType = \case
  E'PriceType'Open  -> "Open"
  E'PriceType'Close -> "Close"

-- | parse 'E'PriceType' enum
toE'PriceType :: Text -> P.Either String E'PriceType
toE'PriceType = \case
  "Open"  -> P.Right E'PriceType'Open
  "Close" -> P.Right E'PriceType'Close
  s       -> P.Left $ "toE'PriceType: enum parse failure: " P.++ P.show s


-- ** E'Qualified

-- | Enum of 'Text' .
-- Refers to the dividend income type:   * P = Partially qualified income   * Q = Qualified income   * N = Unqualified income   * null = N/A or unknown 
data E'Qualified
  = E'Qualified'P -- ^ @"P"@
  | E'Qualified'Q -- ^ @"Q"@
  | E'Qualified'N -- ^ @"N"@
  | E'Qualified'Null -- ^ @"null"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Qualified where
  toJSON = A.toJSON . fromE'Qualified
instance A.FromJSON E'Qualified where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Qualified =<< A.parseJSON o
instance WH.ToHttpApiData E'Qualified where
  toQueryParam = WH.toQueryParam . fromE'Qualified
instance WH.FromHttpApiData E'Qualified where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Qualified
instance MimeRender MimeMultipartFormData E'Qualified where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Qualified' enum
fromE'Qualified :: E'Qualified -> Text
fromE'Qualified = \case
  E'Qualified'P    -> "P"
  E'Qualified'Q    -> "Q"
  E'Qualified'N    -> "N"
  E'Qualified'Null -> "null"

-- | parse 'E'Qualified' enum
toE'Qualified :: Text -> P.Either String E'Qualified
toE'Qualified = \case
  "P"    -> P.Right E'Qualified'P
  "Q"    -> P.Right E'Qualified'Q
  "N"    -> P.Right E'Qualified'N
  "null" -> P.Right E'Qualified'Null
  s      -> P.Left $ "toE'Qualified: enum parse failure: " P.++ P.show s


-- ** E'Range

-- | Enum of 'Text'
data E'Range
  = E'Range'Today -- ^ @"today"@
  | E'Range'1m -- ^ @"1m"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Range where
  toJSON = A.toJSON . fromE'Range
instance A.FromJSON E'Range where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Range =<< A.parseJSON o
instance WH.ToHttpApiData E'Range where
  toQueryParam = WH.toQueryParam . fromE'Range
instance WH.FromHttpApiData E'Range where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Range
instance MimeRender MimeMultipartFormData E'Range where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Range' enum
fromE'Range :: E'Range -> Text
fromE'Range = \case
  E'Range'Today -> "today"
  E'Range'1m    -> "1m"

-- | parse 'E'Range' enum
toE'Range :: Text -> P.Either String E'Range
toE'Range = \case
  "today" -> P.Right E'Range'Today
  "1m"    -> P.Right E'Range'1m
  s       -> P.Left $ "toE'Range: enum parse failure: " P.++ P.show s


-- ** E'Range2

-- | Enum of 'Text'
data E'Range2
  = E'Range2'5y -- ^ @"5y"@
  | E'Range2'2y -- ^ @"2y"@
  | E'Range2'1y -- ^ @"1y"@
  | E'Range2'Ytd -- ^ @"ytd"@
  | E'Range2'6m -- ^ @"6m"@
  | E'Range2'3m -- ^ @"3m"@
  | E'Range2'1m -- ^ @"1m"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Range2 where
  toJSON = A.toJSON . fromE'Range2
instance A.FromJSON E'Range2 where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Range2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Range2 where
  toQueryParam = WH.toQueryParam . fromE'Range2
instance WH.FromHttpApiData E'Range2 where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Range2
instance MimeRender MimeMultipartFormData E'Range2 where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Range2' enum
fromE'Range2 :: E'Range2 -> Text
fromE'Range2 = \case
  E'Range2'5y  -> "5y"
  E'Range2'2y  -> "2y"
  E'Range2'1y  -> "1y"
  E'Range2'Ytd -> "ytd"
  E'Range2'6m  -> "6m"
  E'Range2'3m  -> "3m"
  E'Range2'1m  -> "1m"

-- | parse 'E'Range2' enum
toE'Range2 :: Text -> P.Either String E'Range2
toE'Range2 = \case
  "5y"  -> P.Right E'Range2'5y
  "2y"  -> P.Right E'Range2'2y
  "1y"  -> P.Right E'Range2'1y
  "ytd" -> P.Right E'Range2'Ytd
  "6m"  -> P.Right E'Range2'6m
  "3m"  -> P.Right E'Range2'3m
  "1m"  -> P.Right E'Range2'1m
  s     -> P.Left $ "toE'Range2: enum parse failure: " P.++ P.show s


-- ** E'Reason

-- | Enum of 'Text' .
-- Trading Halt Reasons   * `T1` Halt News Pending   * `IPO1` IPO/New Issue Not Yet Trading   * `IPOD` IPO/New Issue Deferred   * `MCB3` Market-Wide ircuit Breaker Level 3 - Breaked   `NA` Reason Not Available Order Acceptance Period Reasons   * `T2` Halt News Dissemination   * `IPO2` IPO/New Issue Order Acceptance Period   * `IPO3` IPO Pre-Launch Period   * `MCB1` Market-Wide Circuit Breaker Level 1 - Breached   * `MCB2` Market-Wide Circuit Breaker Level 2 - Breached 
data E'Reason
  = E'Reason'T1 -- ^ @"T1"@
  | E'Reason'IPO1 -- ^ @"IPO1"@
  | E'Reason'IPOD -- ^ @"IPOD"@
  | E'Reason'MCB3 -- ^ @"MCB3"@
  | E'Reason'NA -- ^ @"NA"@
  | E'Reason'T2 -- ^ @"T2"@
  | E'Reason'IPO2 -- ^ @"IPO2"@
  | E'Reason'IPO3 -- ^ @"IPO3"@
  | E'Reason'MCB1 -- ^ @"MCB1"@
  | E'Reason'MCB2 -- ^ @"MCB2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Reason where
  toJSON = A.toJSON . fromE'Reason
instance A.FromJSON E'Reason where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Reason =<< A.parseJSON o
instance WH.ToHttpApiData E'Reason where
  toQueryParam = WH.toQueryParam . fromE'Reason
instance WH.FromHttpApiData E'Reason where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Reason
instance MimeRender MimeMultipartFormData E'Reason where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Reason' enum
fromE'Reason :: E'Reason -> Text
fromE'Reason = \case
  E'Reason'T1   -> "T1"
  E'Reason'IPO1 -> "IPO1"
  E'Reason'IPOD -> "IPOD"
  E'Reason'MCB3 -> "MCB3"
  E'Reason'NA   -> "NA"
  E'Reason'T2   -> "T2"
  E'Reason'IPO2 -> "IPO2"
  E'Reason'IPO3 -> "IPO3"
  E'Reason'MCB1 -> "MCB1"
  E'Reason'MCB2 -> "MCB2"

-- | parse 'E'Reason' enum
toE'Reason :: Text -> P.Either String E'Reason
toE'Reason = \case
  "T1"   -> P.Right E'Reason'T1
  "IPO1" -> P.Right E'Reason'IPO1
  "IPOD" -> P.Right E'Reason'IPOD
  "MCB3" -> P.Right E'Reason'MCB3
  "NA"   -> P.Right E'Reason'NA
  "T2"   -> P.Right E'Reason'T2
  "IPO2" -> P.Right E'Reason'IPO2
  "IPO3" -> P.Right E'Reason'IPO3
  "MCB1" -> P.Right E'Reason'MCB1
  "MCB2" -> P.Right E'Reason'MCB2
  s      -> P.Left $ "toE'Reason: enum parse failure: " P.++ P.show s


-- ** E'SecurityEvent

-- | Enum of 'Text'
data E'SecurityEvent
  = E'SecurityEvent'MarketOpen -- ^ @"MarketOpen"@
  | E'SecurityEvent'MarketClose -- ^ @"MarketClose"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SecurityEvent where
  toJSON = A.toJSON . fromE'SecurityEvent
instance A.FromJSON E'SecurityEvent where
  parseJSON o =
    P.either P.fail (pure . P.id) . toE'SecurityEvent =<< A.parseJSON o
instance WH.ToHttpApiData E'SecurityEvent where
  toQueryParam = WH.toQueryParam . fromE'SecurityEvent
instance WH.FromHttpApiData E'SecurityEvent where
  parseQueryParam o =
    WH.parseQueryParam o >>= P.left T.pack . toE'SecurityEvent
instance MimeRender MimeMultipartFormData E'SecurityEvent where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SecurityEvent' enum
fromE'SecurityEvent :: E'SecurityEvent -> Text
fromE'SecurityEvent = \case
  E'SecurityEvent'MarketOpen  -> "MarketOpen"
  E'SecurityEvent'MarketClose -> "MarketClose"

-- | parse 'E'SecurityEvent' enum
toE'SecurityEvent :: Text -> P.Either String E'SecurityEvent
toE'SecurityEvent = \case
  "MarketOpen" -> P.Right E'SecurityEvent'MarketOpen
  "MarketClose" -> P.Right E'SecurityEvent'MarketClose
  s -> P.Left $ "toE'SecurityEvent: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' .
-- * `H` Trading halted across all US equity markets * `O` Trading halt released into an ORder Acceptance Period (IEX-listed securities only) * `P` Trading paused and Order Acceptance Period on IEX (IEX-listed securities only) * `T` Trading on IEX 
data E'Status
  = E'Status'H -- ^ @"H"@
  | E'Status'O -- ^ @"O"@
  | E'Status'P -- ^ @"P"@
  | E'Status'T -- ^ @"T"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where
  toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where
  toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'H -> "H"
  E'Status'O -> "O"
  E'Status'P -> "P"
  E'Status'T -> "T"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "H" -> P.Right E'Status'H
  "O" -> P.Right E'Status'O
  "P" -> P.Right E'Status'P
  "T" -> P.Right E'Status'T
  s   -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'SystemEvent

-- | Enum of 'Text' .
-- The System event message is used to indicate events that apply to the market or the data feed. There will be a single message disseminated  per channel for each System Event type within a given trading  session. values:   * `O` - start of message   * `S` - start of system hours   * `R` - start of regular market hours   * `M` - end of regular market hours   * `E` - end of system hours   * `C` - end of message 
data E'SystemEvent
  = E'SystemEvent'O -- ^ @"O"@
  | E'SystemEvent'S -- ^ @"S"@
  | E'SystemEvent'R -- ^ @"R"@
  | E'SystemEvent'M -- ^ @"M"@
  | E'SystemEvent'E -- ^ @"E"@
  | E'SystemEvent'C -- ^ @"C"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SystemEvent where
  toJSON = A.toJSON . fromE'SystemEvent
instance A.FromJSON E'SystemEvent where
  parseJSON o =
    P.either P.fail (pure . P.id) . toE'SystemEvent =<< A.parseJSON o
instance WH.ToHttpApiData E'SystemEvent where
  toQueryParam = WH.toQueryParam . fromE'SystemEvent
instance WH.FromHttpApiData E'SystemEvent where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SystemEvent
instance MimeRender MimeMultipartFormData E'SystemEvent where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SystemEvent' enum
fromE'SystemEvent :: E'SystemEvent -> Text
fromE'SystemEvent = \case
  E'SystemEvent'O -> "O"
  E'SystemEvent'S -> "S"
  E'SystemEvent'R -> "R"
  E'SystemEvent'M -> "M"
  E'SystemEvent'E -> "E"
  E'SystemEvent'C -> "C"

-- | parse 'E'SystemEvent' enum
toE'SystemEvent :: Text -> P.Either String E'SystemEvent
toE'SystemEvent = \case
  "O" -> P.Right E'SystemEvent'O
  "S" -> P.Right E'SystemEvent'S
  "R" -> P.Right E'SystemEvent'R
  "M" -> P.Right E'SystemEvent'M
  "E" -> P.Right E'SystemEvent'E
  "C" -> P.Right E'SystemEvent'C
  s   -> P.Left $ "toE'SystemEvent: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' .
-- refers to the common issue type:   * ad = ADR   * re = REIT   * ce = Closed end fund   * si = Secondary issue   * lp = Limited partnerships   * cs = Common stock   * et = ETF 
data E'Type
  = E'Type'Ad -- ^ @"ad"@
  | E'Type'Re -- ^ @"re"@
  | E'Type'Ce -- ^ @"ce"@
  | E'Type'Si -- ^ @"si"@
  | E'Type'Lp -- ^ @"lp"@
  | E'Type'Cs -- ^ @"cs"@
  | E'Type'Et -- ^ @"et"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where
  toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where
  toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Ad -> "ad"
  E'Type'Re -> "re"
  E'Type'Ce -> "ce"
  E'Type'Si -> "si"
  E'Type'Lp -> "lp"
  E'Type'Cs -> "cs"
  E'Type'Et -> "et"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "ad" -> P.Right E'Type'Ad
  "re" -> P.Right E'Type'Re
  "ce" -> P.Right E'Type'Ce
  "si" -> P.Right E'Type'Si
  "lp" -> P.Right E'Type'Lp
  "cs" -> P.Right E'Type'Cs
  "et" -> P.Right E'Type'Et
  s    -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' .
-- Refers to the dividend payment type 
data E'Type2
  = E'Type2'Dividend_income -- ^ @"Dividend income"@
  | E'Type2'Interest_income -- ^ @"Interest income"@
  | E'Type2'Stock_dividend -- ^ @"Stock dividend"@
  | E'Type2'Short_term_capital_gain -- ^ @"Short term capital gain"@
  | E'Type2'Medium_term_capital_gain -- ^ @"Medium term capital gain"@
  | E'Type2'Long_term_capital_gain -- ^ @"Long term capital gain"@
  | E'Type2'Unspecified_term_capital_gain -- ^ @"Unspecified term capital gain"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where
  toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where
  parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where
  toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Dividend_income               -> "Dividend income"
  E'Type2'Interest_income               -> "Interest income"
  E'Type2'Stock_dividend                -> "Stock dividend"
  E'Type2'Short_term_capital_gain       -> "Short term capital gain"
  E'Type2'Medium_term_capital_gain      -> "Medium term capital gain"
  E'Type2'Long_term_capital_gain        -> "Long term capital gain"
  E'Type2'Unspecified_term_capital_gain -> "Unspecified term capital gain"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "Dividend income"          -> P.Right E'Type2'Dividend_income
  "Interest income"          -> P.Right E'Type2'Interest_income
  "Stock dividend"           -> P.Right E'Type2'Stock_dividend
  "Short term capital gain"  -> P.Right E'Type2'Short_term_capital_gain
  "Medium term capital gain" -> P.Right E'Type2'Medium_term_capital_gain
  "Long term capital gain"   -> P.Right E'Type2'Long_term_capital_gain
  "Unspecified term capital gain" ->
    P.Right E'Type2'Unspecified_term_capital_gain
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** ModelList

-- | Enum of 'Text'
data ModelList
  = ModelList'Mostactive -- ^ @"mostactive"@
  | ModelList'Gainers -- ^ @"gainers"@
  | ModelList'Losers -- ^ @"losers"@
  | ModelList'Iexvolume -- ^ @"iexvolume"@
  | ModelList'Iexpercent -- ^ @"iexpercent"@
  | ModelList'Infocus -- ^ @"infocus"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelList where
  toJSON = A.toJSON . fromModelList
instance A.FromJSON ModelList where
  parseJSON o = P.either P.fail (pure . P.id) . toModelList =<< A.parseJSON o
instance WH.ToHttpApiData ModelList where
  toQueryParam = WH.toQueryParam . fromModelList
instance WH.FromHttpApiData ModelList where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelList
instance MimeRender MimeMultipartFormData ModelList where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelList' enum
fromModelList :: ModelList -> Text
fromModelList = \case
  ModelList'Mostactive -> "mostactive"
  ModelList'Gainers    -> "gainers"
  ModelList'Losers     -> "losers"
  ModelList'Iexvolume  -> "iexvolume"
  ModelList'Iexpercent -> "iexpercent"
  ModelList'Infocus    -> "infocus"

-- | parse 'ModelList' enum
toModelList :: Text -> P.Either String ModelList
toModelList = \case
  "mostactive" -> P.Right ModelList'Mostactive
  "gainers"    -> P.Right ModelList'Gainers
  "losers"     -> P.Right ModelList'Losers
  "iexvolume"  -> P.Right ModelList'Iexvolume
  "iexpercent" -> P.Right ModelList'Iexpercent
  "infocus"    -> P.Right ModelList'Infocus
  s            -> P.Left $ "toModelList: enum parse failure: " P.++ P.show s


-- ** Sector

-- | Enum of 'Text'
data Sector
  = Sector'Consumer_Staples -- ^ @"Consumer Staples"@
  | Sector'Utilities -- ^ @"Utilities"@
  | Sector'Real_Estate -- ^ @"Real Estate"@
  | Sector'Energy -- ^ @"Energy"@
  | Sector'Health_Care -- ^ @"Health Care"@
  | Sector'Financials -- ^ @"Financials"@
  | Sector'Industrials -- ^ @"Industrials"@
  | Sector'Consumer_Discretionary -- ^ @"Consumer Discretionary"@
  | Sector'Materials -- ^ @"Materials"@
  | Sector'Technology -- ^ @"Technology"@
  | Sector'Communication_Services -- ^ @"Communication Services"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Sector where
  toJSON = A.toJSON . fromSector
instance A.FromJSON Sector where
  parseJSON o = P.either P.fail (pure . P.id) . toSector =<< A.parseJSON o
instance WH.ToHttpApiData Sector where
  toQueryParam = WH.toQueryParam . fromSector
instance WH.FromHttpApiData Sector where
  parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSector
instance MimeRender MimeMultipartFormData Sector where
  mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Sector' enum
fromSector :: Sector -> Text
fromSector = \case
  Sector'Consumer_Staples       -> "Consumer Staples"
  Sector'Utilities              -> "Utilities"
  Sector'Real_Estate            -> "Real Estate"
  Sector'Energy                 -> "Energy"
  Sector'Health_Care            -> "Health Care"
  Sector'Financials             -> "Financials"
  Sector'Industrials            -> "Industrials"
  Sector'Consumer_Discretionary -> "Consumer Discretionary"
  Sector'Materials              -> "Materials"
  Sector'Technology             -> "Technology"
  Sector'Communication_Services -> "Communication Services"

-- | parse 'Sector' enum
toSector :: Text -> P.Either String Sector
toSector = \case
  "Consumer Staples"       -> P.Right Sector'Consumer_Staples
  "Utilities"              -> P.Right Sector'Utilities
  "Real Estate"            -> P.Right Sector'Real_Estate
  "Energy"                 -> P.Right Sector'Energy
  "Health Care"            -> P.Right Sector'Health_Care
  "Financials"             -> P.Right Sector'Financials
  "Industrials"            -> P.Right Sector'Industrials
  "Consumer Discretionary" -> P.Right Sector'Consumer_Discretionary
  "Materials"              -> P.Right Sector'Materials
  "Technology"             -> P.Right Sector'Technology
  "Communication Services" -> P.Right Sector'Communication_Services
  s -> P.Left $ "toSector: enum parse failure: " P.++ P.show s



